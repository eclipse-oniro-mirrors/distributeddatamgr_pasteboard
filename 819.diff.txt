diff --git a/BUILD.gn b/BUILD.gn
index a79002ff2568f32f1591d23f23d6d218d1812895..4257ce901afa29a22843a7e77c78fbf6d7d5967a 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -23,6 +23,7 @@ group("pasteboard_packages") {
       "framework/innerkits:pasteboard_client",
       "interfaces/cj:cj_pasteboard_ffi",
       "interfaces/kits:pasteboard_napi",
+      "interfaces/ndk:libpasteboard",
       "profile:distributeddatamgr_pasteboard_sa_profiles",
       "services:pasteboard_service",
     ]
diff --git a/bundle.json b/bundle.json
index 6d3913ce0f905a6d69538b43d612f31741c47fed..eb13be8a2a18aea3120c540dc318965665f30f6b 100644
--- a/bundle.json
+++ b/bundle.json
@@ -104,6 +104,16 @@
               ],
               "header_base":"//foundation/distributeddatamgr/pasteboard/framework/framework/include"
             }
+          },
+          {
+            "name": "//foundation/distributeddatamgr/pasteboard/interfaces/ndk:libpasteboard",
+            "header": {
+              "header_files": [
+                "oh_pasteboard.h",
+                "oh_pasteboard_err_code.h"
+              ],
+              "header_base":"//foundation/distributeddatamgr/pasteboard/interfaces/ndk/include"
+            }
           }
         ],
         "test": [
@@ -111,7 +121,8 @@
           "//foundation/distributeddatamgr/pasteboard/services/test:unittest",
           "//foundation/distributeddatamgr/pasteboard/test/fuzztest:fuzztest",
           "//foundation/distributeddatamgr/pasteboard/interfaces/kits/napi/test/unittest/pasteboardapi:unittest",
-          "//foundation/distributeddatamgr/pasteboard/interfaces/kits/napi/test/unittest/pasteboardperf:unittest"
+          "//foundation/distributeddatamgr/pasteboard/interfaces/kits/napi/test/unittest/pasteboardperf:unittest",
+          "//foundation/distributeddatamgr/pasteboard/interfaces/ndk/unittest:unittest"
         ]
       },
         "hisysevent_config": [
diff --git a/framework/innerkits/BUILD.gn b/framework/innerkits/BUILD.gn
index e1e024228b99e88edbe7c81df2a1c5afec30c03f..511ad449f6fd32bacb1ceb17e2bc29b023597700 100644
--- a/framework/innerkits/BUILD.gn
+++ b/framework/innerkits/BUILD.gn
@@ -44,11 +44,16 @@ ohos_shared_library("pasteboard_client") {
     "${pasteboard_service_path}/zidl/src/ipasteboard_client_death_observer.cpp",
     "${pasteboard_service_path}/zidl/src/pasteboard_delay_getter_client.cpp",
     "${pasteboard_service_path}/zidl/src/pasteboard_delay_getter_stub.cpp",
+    "${pasteboard_service_path}/zidl/src/pasteboard_entry_getter_client.cpp",
+    "${pasteboard_service_path}/zidl/src/pasteboard_entry_getter_stub.cpp",
     "${pasteboard_service_path}/zidl/src/pasteboard_observer_stub.cpp",
     "${pasteboard_service_path}/zidl/src/pasteboard_service_proxy.cpp",
+    "src/convert_utils.cpp",
     "src/paste_data.cpp",
+    "src/paste_data_entry.cpp",
     "src/paste_data_record.cpp",
     "src/pasteboard_client.cpp",
+    "src/pasteboard_entry_getter.cpp",
     "src/pasteboard_load_callback.cpp",
     "src/pasteboard_observer.cpp",
     "src/pasteboard_utils.cpp",
diff --git a/framework/innerkits/include/convert_utils.h b/framework/innerkits/include/convert_utils.h
new file mode 100644
index 0000000000000000000000000000000000000000..4c851ba037f075b09b6ec7562b7dcd50bfdd9c97
--- /dev/null
+++ b/framework/innerkits/include/convert_utils.h
@@ -0,0 +1,57 @@
+/*
+* Copyright (C) 2024 Huawei Device Co., Ltd.
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#ifndef PASTE_BOARD_CONVERT_UTILS_H
+#define PASTE_BOARD_CONVERT_UTILS_H
+
+#include "paste_data.h"
+#include "unified_data.h"
+namespace OHOS {
+namespace MiscServices {
+class API_EXPORT ConvertUtils {
+public:
+    using UnifiedRecord = UDMF::UnifiedRecord;
+    using UnifiedData = UDMF::UnifiedData;
+    using UnifiedDataProperties = UDMF::UnifiedDataProperties;
+    using UDType = UDMF::UDType;
+
+    static std::shared_ptr<PasteData> Convert(const UnifiedData& unifiedData);
+    static std::shared_ptr<UnifiedData> Convert(const PasteData& pasteData);
+
+    static std::vector<std::shared_ptr<PasteDataRecord>> Convert(
+        const std::vector<std::shared_ptr<UnifiedRecord>>& records);
+    static std::vector<std::shared_ptr<UnifiedRecord>> Convert(
+        const std::vector<std::shared_ptr<PasteDataRecord>>& records);
+
+    static std::shared_ptr<PasteDataRecord> Convert(std::shared_ptr<UnifiedRecord> record);
+    static std::shared_ptr<UnifiedRecord> Convert(std::shared_ptr<PasteDataRecord> record);
+
+    static PasteDataProperty ConvertProperty(const std::shared_ptr<UnifiedDataProperties>& properties,
+        const UnifiedData& unifiedData);
+    static std::shared_ptr<UnifiedDataProperties> ConvertProperty(const PasteDataProperty& properties);
+
+    static std::vector<std::shared_ptr<PasteDataEntry>> Convert(
+        const std::shared_ptr<std::map<std::string, UDMF::ValueType>>& entries);
+    static std::shared_ptr<std::map<std::string, UDMF::ValueType>> Convert(
+        const std::vector<std::shared_ptr<PasteDataEntry>>& entries);
+
+    static std::vector<std::string> Convert(const std::vector<std::string>& utdIds);
+
+private:
+    static constexpr const char *CHANNEL_NAME = "pasteboard";
+};
+} // namespace MiscServices
+} // namespace OHOS
+#endif // PASTE_BOARD_CONVERT_UTILS_H
\ No newline at end of file
diff --git a/framework/innerkits/include/paste_data.h b/framework/innerkits/include/paste_data.h
index 003bf7381dbf7cf1419bf44447f4dc02762a8bbe..62af3a8015efe2400cbacc2a13f25ac8d0bcbec3 100644
--- a/framework/innerkits/include/paste_data.h
+++ b/framework/innerkits/include/paste_data.h
@@ -127,6 +127,10 @@ public:
 
     void SetDelayData(bool isDelay);
     bool IsDelayData() const;
+    void SetDelayRecord(bool isDelay);
+    bool IsDelayRecord() const;
+    void SetDataId(uint32_t dataId);
+    uint32_t GetDataId() const;
     bool Marshalling(Parcel &parcel) const override;
     static PasteData* Unmarshalling(Parcel &parcel);
     void SetPasteId(const std::string &pasteId);
@@ -157,6 +161,9 @@ private:
     bool isLocalPaste_ = false; // local in app paste
     bool isDelayData_ = false;
     std::string pasteId_;
+    bool isDelayRecord_ = false;
+    uint32_t dataId_ = 0;
+    uint32_t recordId_ = 0;
 };
 } // namespace MiscServices
 } // namespace OHOS
diff --git a/framework/innerkits/include/paste_data_entry.h b/framework/innerkits/include/paste_data_entry.h
new file mode 100644
index 0000000000000000000000000000000000000000..87fdc0106e9f3fded07e78a81cf0c72d54819da1
--- /dev/null
+++ b/framework/innerkits/include/paste_data_entry.h
@@ -0,0 +1,87 @@
+/*
+* Copyright (C) 2024 Huawei Device Co., Ltd.
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#ifndef PASTE_BOARD_ENTRY_H
+#define PASTE_BOARD_ENTRY_H
+
+#include "tlv_object.h"
+#include "unified_meta.h"
+#include "uri.h"
+namespace OHOS {
+namespace MiscServices {
+namespace {
+constexpr const char* MIMETYPE_PIXELMAP = "pixelMap";
+constexpr const char* MIMETYPE_TEXT_HTML = "text/html";
+constexpr const char* MIMETYPE_TEXT_PLAIN = "text/plain";
+constexpr const char* MIMETYPE_TEXT_URI = "text/uri";
+constexpr const char* MIMETYPE_TEXT_WANT = "text/want";
+} // namespace
+class API_EXPORT MineCustomData : public TLVObject {
+public:
+    MineCustomData() = default;
+    std::map<std::string, std::vector<uint8_t>> GetItemData();
+    void AddItemData(const std::string& mimeType, const std::vector<uint8_t>& arrayBuffer);
+    bool Encode(std::vector<std::uint8_t>& buffer) override;
+    bool Decode(const std::vector<std::uint8_t>& buffer) override;
+    size_t Count() override;
+
+private:
+    std::map<std::string, std::vector<uint8_t>> itemData_;
+};
+
+class API_EXPORT PasteDataEntry : public TLVObject {
+public:
+    using UDType = UDMF::UDType;
+    PasteDataEntry() = default;
+    PasteDataEntry& operator=(const PasteDataEntry& entry);
+    PasteDataEntry(const std::string& utdId, const EntryValue& value);
+    PasteDataEntry(const std::string& utdId, const std::string& mimeType, const EntryValue& value);
+
+    std::shared_ptr<std::string> ConvertToPlianText() const;
+    std::shared_ptr<std::string> ConvertToHtml() const;
+    std::shared_ptr<Uri> ConvertToUri() const;
+    std::shared_ptr<AAFwk::Want> ConvertToWant() const;
+    std::shared_ptr<Media::PixelMap> ConvertToPixelMap() const;
+    std::shared_ptr<MineCustomData> ConvertToCustomData() const;
+
+    void SetValue(const EntryValue& value);
+    EntryValue GetValue() const;
+    void SetUtdId(const std::string& utdId);
+    std::string GetUtdId() const;
+    void SetMimeType(const std::string& mimeType);
+    std::string GetMimeType() const;
+    bool Encode(std::vector<std::uint8_t>& buffer) override;
+    bool Decode(const std::vector<std::uint8_t>& buffer) override;
+    size_t Count() override;
+
+    bool Marshalling(std::vector<std::uint8_t>& buffer);
+    bool Unmarshalling(const std::vector<std::uint8_t>& buffer);
+private:
+    std::string utdId_;
+    std::string mimeType_; // pasteboard mimeType
+    EntryValue value_;
+};
+
+class API_EXPORT CommonUtils {
+public:
+    using UDType = UDMF::UDType;
+    static std::string Convert(UDType uDType);
+    static std::string Convert2MimeType(const std::string& utdId);
+    static UDType Convert(int32_t uDType, const std::string& mimeType);
+    static std::string Convert2UtdId(int32_t uDType, const std::string& mimeType);
+};
+} // namespace MiscServices
+} // namespace OHOS
+#endif // PASTE_BOARD_ENTRY_H
\ No newline at end of file
diff --git a/framework/innerkits/include/paste_data_record.h b/framework/innerkits/include/paste_data_record.h
index 5b72677020eedf9dee764fcc024e39844f63635d..ab184e882961d64a1a349978a11f668376a28dd0 100644
--- a/framework/innerkits/include/paste_data_record.h
+++ b/framework/innerkits/include/paste_data_record.h
@@ -21,6 +21,7 @@
 
 #include "common/constant.h"
 #include "message_parcel.h"
+#include "paste_data_entry.h"
 #include "pixel_map.h"
 #include "string_ex.h"
 #include "tlv_object.h"
@@ -31,20 +32,6 @@
 namespace OHOS {
 namespace MiscServices {
 enum ResultCode : int32_t { OK = 0, IPC_NO_DATA, IPC_ERROR };
-
-class API_EXPORT MineCustomData : public TLVObject {
-public:
-    MineCustomData() = default;
-    std::map<std::string, std::vector<uint8_t>> GetItemData();
-    void AddItemData(const std::string &mimeType, const std::vector<uint8_t> &arrayBuffer);
-    bool Encode(std::vector<std::uint8_t> &buffer) override;
-    bool Decode(const std::vector<std::uint8_t> &buffer) override;
-    size_t Count() override;
-
-private:
-    std::map<std::string, std::vector<uint8_t>> itemData_;
-};
-
 class FileDescriptor {
 public:
     FileDescriptor() = default;
@@ -98,8 +85,6 @@ public:
     std::string GetConvertUri() const;
     void SetGrantUriPermission(bool hasPermission);
     bool HasGrantUriPermission();
-    static std::shared_ptr<OHOS::Media::PixelMap> Vector2PixelMap(std::vector<std::uint8_t> &value);
-    static std::vector<std::uint8_t> PixelMap2Vector(std::shared_ptr<OHOS::Media::PixelMap> &pixelMap);
 
     void SetTextContent(const std::string& content);
     std::string GetTextContent() const;
@@ -110,6 +95,21 @@ public:
     int32_t GetUDType() const;
     void SetUDType(int32_t type);
 
+    bool IsEmpty() const;
+    void SetUDMFValue(const std::shared_ptr<EntryValue>& udmfValue);
+    std::shared_ptr<EntryValue> GetUDMFValue() const;
+    void AddEntry(const std::string& utdType, std::shared_ptr<PasteDataEntry> value);
+    std::shared_ptr<PasteDataEntry> GetEntry(const std::string& utdType) const;
+    std::vector<std::shared_ptr<PasteDataEntry>> GetEntries() const;
+    std::vector<std::string> GetValidTypes(const std::vector<std::string>& types) const;
+
+    void SetDelayRecordFlag(bool isDelay);
+    bool IsDelayRecord() const;
+    void SetDataId(uint32_t dataId);
+    uint32_t GetDataId() const;
+    void SetRecordId(uint32_t recordId);
+    uint32_t GetRecordId() const;
+
     class Builder {
     public:
         explicit Builder(const std::string &mimeType);
@@ -132,6 +132,8 @@ private:
         return resultCode == ResultCode::OK;
     }
     std::string GetPassUri();
+    void AddUriEntry();
+    std::set<std::string> GetUdtTypes() const;
 
     std::string mimeType_;
     std::shared_ptr<std::string> htmlText_;
@@ -151,6 +153,11 @@ private:
     std::shared_ptr<Details> details_;
     std::string textContent_;
     std::shared_ptr<Details> systemDefinedContents_;
+    std::shared_ptr<EntryValue> udmfValue_;
+    std::vector<std::shared_ptr<PasteDataEntry>> entries_;
+    uint32_t dataId_ = 0;
+    uint32_t recordId_ = 0;
+    bool isDelay_ = false;
 };
 } // namespace MiscServices
 } // namespace OHOS
diff --git a/framework/innerkits/include/pasteboard_client.h b/framework/innerkits/include/pasteboard_client.h
index ce5a07ab82681620fcccd074102da37b25a396ac..8d5930e724b960fe87c091d366493aa5707e967c 100644
--- a/framework/innerkits/include/pasteboard_client.h
+++ b/framework/innerkits/include/pasteboard_client.h
@@ -143,6 +143,16 @@ public:
     */
     std::shared_ptr<PasteData> CreateKvData(const std::string &mimeType, const std::vector<uint8_t> &arrayBuffer);
 
+    /**
+    * GetRecordValueByType
+    * @descrition get entry value from the pasteboard.
+    * @param dataId the dataId of the PasteData.
+    * @param recordId the recordId of the PasteRecord.
+    * @param value the value of the PasteDataEntry.
+    * @return int32_t.
+    */
+    int32_t GetRecordValueByType(uint32_t dataId, uint32_t recordId, PasteDataEntry& value);
+
     /**
      * GetPasteData
      * @descrition get paste data from the pasteboard.
@@ -168,10 +178,13 @@ public:
     /**
      * SetPasteData
      * @descrition set paste data to the pasteboard.
-     * @param pasteData the object of the PasteDate.
+     * @param pasteData the object of the PasteData.
+     * @param pasteData the object of the PasteboardDelayGetter.
+     * @param pasteData the map of the EntryGetter.
      * @return int32_t.
      */
-    int32_t SetPasteData(PasteData &pasteData, std::shared_ptr<PasteboardDelayGetter> delayGetter = nullptr);
+    int32_t SetPasteData(PasteData &pasteData, std::shared_ptr<PasteboardDelayGetter> delayGetter = nullptr,
+        std::map<uint32_t, std::shared_ptr<UDMF::EntryGetter>> entryGetters = {});
 
     /**
      * SetPasteData
@@ -190,6 +203,22 @@ public:
      */
     int32_t GetUnifiedData(UDMF::UnifiedData &unifiedData);
 
+    /**
+    * SetUdsdData
+    * @descrition set unified data with uds entries to the pasteboard.
+    * @param unifiedData the object of the PasteDate.
+    * @return int32_t.
+    */
+    int32_t SetUdsdData(const UDMF::UnifiedData& unifiedData);
+
+    /**
+    * GetUnifiedDataWithEntry
+    * @descrition get unified data with uds entries from the pasteboard.
+    * @param unifiedData the object of the PasteDate.
+    * @return int32_t.
+    */
+    int32_t GetUdsdData(UDMF::UnifiedData& unifiedData);
+
     /**
      * IsRemoteData
      * @descrition check if remote data.
diff --git a/framework/innerkits/include/pasteboard_entry_getter.h b/framework/innerkits/include/pasteboard_entry_getter.h
new file mode 100644
index 0000000000000000000000000000000000000000..23c6564832d0a148666780b274a38513e8d5dc93
--- /dev/null
+++ b/framework/innerkits/include/pasteboard_entry_getter.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef PASTEBOARD_ENTRY_GETTER_H
+#define PASTEBOARD_ENTRY_GETTER_H
+
+#include "getter_system.h"
+
+namespace OHOS {
+namespace MiscServices {
+class PasteboardEntryGetter : public UDMF::GetterSystem::GeneralGetter {
+public:
+    PasteboardEntryGetter() = default;
+    ~PasteboardEntryGetter() = default;
+    UDMF::ValueType GetValueByType(uint32_t dataId, uint32_t recordId, const std::string &utdId) override;
+private:
+    class Factory {
+    public:
+        Factory();
+        ~Factory();
+    private:
+        std::shared_ptr<PasteboardEntryGetter> getter_;
+    };
+    static Factory factory_;
+};
+} // namespace MiscServices
+} // namespace OHOS
+#endif // PASTEBOARD_ENTRY_GETTER_H
\ No newline at end of file
diff --git a/framework/innerkits/include/pasteboard_utils.h b/framework/innerkits/include/pasteboard_utils.h
index 69148209d3dce347585331753413770b00d44eb2..12c3e8cb8bee5c76e00dc26fada92741474d32dc 100644
--- a/framework/innerkits/include/pasteboard_utils.h
+++ b/framework/innerkits/include/pasteboard_utils.h
@@ -40,7 +40,7 @@ private:
     std::vector<std::shared_ptr<PasteDataRecord>> Convert(const std::vector<std::shared_ptr<UnifiedRecord>>& records);
     static PasteDataProperty Convert(const UnifiedDataProperties& properties);
     static std::shared_ptr<UnifiedDataProperties> Convert(const PasteDataProperty& properties);
-    static std::vector<std::string> Convert(const std::vector<UDType>& uDTypes);
+    static std::vector<std::string> Convert(const std::vector<std::string>& utdIds);
     static std::string Convert(UDType uDType);
     static UDType Convert(int32_t uDType, const std::string& mimeType);
 
diff --git a/framework/innerkits/src/convert_utils.cpp b/framework/innerkits/src/convert_utils.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..680ec6fc960f45f489a7796dbd29558b4448a7fe
--- /dev/null
+++ b/framework/innerkits/src/convert_utils.cpp
@@ -0,0 +1,173 @@
+/*
+* Copyright (C) 2024 Huawei Device Co., Ltd.
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+#include "convert_utils.h"
+
+#include "pasteboard_hilog.h"
+#include "unified_meta.h"
+namespace OHOS {
+namespace MiscServices {
+using UnifiedRecord = UDMF::UnifiedRecord;
+using UnifiedData = UDMF::UnifiedData;
+using UnifiedDataProperties = UDMF::UnifiedDataProperties;
+using UDType = UDMF::UDType;
+
+std::shared_ptr<PasteData> ConvertUtils::Convert(const UnifiedData& unifiedData)
+{
+    auto pasteData = std::make_shared<PasteData>(Convert(unifiedData.GetRecords()));
+    pasteData->SetProperty(ConvertProperty(unifiedData.GetProperties(), unifiedData));
+    return pasteData;
+}
+
+std::shared_ptr<UnifiedData> ConvertUtils::Convert(const PasteData& pasteData)
+{
+    auto unifiedData = std::make_shared<UnifiedData>();
+    unifiedData->SetRecords(Convert(pasteData.AllRecords()));
+    unifiedData->SetProperties(ConvertProperty(pasteData.GetProperty()));
+    unifiedData->SetDataId(pasteData.GetDataId());
+    return unifiedData;
+}
+
+std::vector<std::shared_ptr<UnifiedRecord>> ConvertUtils::Convert(
+    const std::vector<std::shared_ptr<PasteDataRecord>>& records)
+{
+    std::vector<std::shared_ptr<UnifiedRecord>> unifiedRecords;
+    for (auto const& record : records) {
+        unifiedRecords.emplace_back(Convert(record));
+    }
+    return unifiedRecords;
+}
+
+std::vector<std::shared_ptr<PasteDataRecord>> ConvertUtils::Convert(
+    const std::vector<std::shared_ptr<UnifiedRecord>>& records)
+{
+    std::vector<std::shared_ptr<PasteDataRecord>> pasteboardRecords;
+    for (auto const& record : records) {
+        pasteboardRecords.emplace_back(Convert(record));
+    }
+    return pasteboardRecords;
+}
+
+std::shared_ptr<UnifiedRecord> ConvertUtils::Convert(std::shared_ptr<PasteDataRecord> record)
+{
+    if (record == nullptr) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "paste record is nullptr");
+        return nullptr;
+    }
+    std::shared_ptr<UnifiedRecord> udmfRecord = std::make_shared<UnifiedRecord>();
+    auto entries = Convert(record->GetEntries());
+    if (entries == nullptr) {
+        PASTEBOARD_HILOGW(PASTEBOARD_MODULE_CLIENT, "entries is nullptr");
+        return udmfRecord;
+    }
+    for (auto &[utdId, value] : *entries) {
+        udmfRecord->AddEntry(utdId, std::move(value));
+    }
+    udmfRecord->SetChannelName(CHANNEL_NAME);
+    udmfRecord->SetDataId(record->GetDataId());
+    udmfRecord->SetRecordId(record->GetRecordId());
+    return udmfRecord;
+}
+
+std::shared_ptr<PasteDataRecord> ConvertUtils::Convert(std::shared_ptr<UnifiedRecord> record)
+{
+    if (record == nullptr) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "udmfRecord is nullptr");
+        return nullptr;
+    }
+    std::shared_ptr<PasteDataRecord> pbRecord = std::make_shared<PasteDataRecord>();
+    auto utdId = record->GetUtdId();
+    pbRecord->AddEntry(utdId, std::make_shared<PasteDataEntry>(utdId, record->GetValue()));
+    for (auto const& entry : Convert(record->GetEntries())) {
+        if (entry == nullptr) {
+            PASTEBOARD_HILOGW(PASTEBOARD_MODULE_CLIENT, "entry is empty");
+            continue;
+        }
+        if (utdId == entry->GetUtdId()) {
+            continue;
+        }
+        pbRecord->AddEntry(entry->GetUtdId(), entry);
+    }
+    pbRecord->SetDataId(record->GetDataId());
+    pbRecord->SetRecordId(record->GetRecordId());
+    if (record->GetEntryGetter() != nullptr) {
+        pbRecord->SetDelayRecordFlag(true);
+    }
+    return pbRecord;
+}
+
+std::vector<std::shared_ptr<PasteDataEntry>> ConvertUtils::Convert(
+    const std::shared_ptr<std::map<std::string, UDMF::ValueType>>& entries)
+{
+    std::vector<std::shared_ptr<PasteDataEntry>> pbEntries;
+    if (entries == nullptr) {
+        PASTEBOARD_HILOGW(PASTEBOARD_MODULE_CLIENT, "pbEntries is empty");
+        return pbEntries;
+    }
+    for (auto const& [utdId, value] : *entries) {
+        pbEntries.emplace_back(std::make_shared<PasteDataEntry>(utdId, value));
+    }
+    return pbEntries;
+}
+
+std::shared_ptr<std::map<std::string, UDMF::ValueType>> ConvertUtils::Convert(
+    const std::vector<std::shared_ptr<PasteDataEntry>>& entries)
+{
+    std::map<std::string, UDMF::ValueType> udmfEntries;
+    for (auto const& entry : entries) {
+        if (entry == nullptr) {
+            continue;
+        }
+        udmfEntries.emplace(entry->GetUtdId(), entry->GetValue());
+    }
+    return std::make_shared<std::map<std::string, UDMF::ValueType>>(udmfEntries);
+}
+
+PasteDataProperty ConvertUtils::ConvertProperty(const std::shared_ptr<UnifiedDataProperties>& properties,
+    const UnifiedData& unifiedData)
+{
+    if (!properties) {
+        return {};
+    }
+    PasteDataProperty pasteDataProperty;
+    pasteDataProperty.shareOption = static_cast<ShareOption>(properties->shareOptions);
+    pasteDataProperty.additions = properties->extras;
+    pasteDataProperty.timestamp = properties->timestamp;
+    pasteDataProperty.tag = properties->tag;
+    auto utdIds = unifiedData.GetTypesLabels();
+    pasteDataProperty.mimeTypes = Convert(utdIds);
+    return PasteDataProperty(pasteDataProperty);
+}
+
+std::shared_ptr<UnifiedDataProperties> ConvertUtils::ConvertProperty(const PasteDataProperty& properties)
+{
+    auto unifiedDataProperties = std::make_shared<UnifiedDataProperties>();
+    unifiedDataProperties->shareOptions = properties.shareOption == InApp ? UDMF::ShareOptions::IN_APP
+                                                                          : UDMF::ShareOptions::CROSS_APP;
+    unifiedDataProperties->extras = properties.additions;
+    unifiedDataProperties->timestamp = properties.timestamp;
+    unifiedDataProperties->tag = properties.tag;
+    return unifiedDataProperties;
+}
+
+std::vector<std::string> ConvertUtils::Convert(const std::vector<std::string>& utdIds)
+{
+    std::vector<std::string> types;
+    for (const auto& utdId : utdIds) {
+        types.push_back(CommonUtils::Convert2MimeType(utdId));
+    }
+    return types;
+}
+} // namespace MiscServices
+} // namespace OHOS
\ No newline at end of file
diff --git a/framework/innerkits/src/paste_data.cpp b/framework/innerkits/src/paste_data.cpp
index 1d33a4326a847339991c8c671139e912d8b44d2f..efd4dc7884eb3a31ad74257bd02056bf1920de40 100644
--- a/framework/innerkits/src/paste_data.cpp
+++ b/framework/innerkits/src/paste_data.cpp
@@ -36,6 +36,8 @@ enum TAG_PASTEBOARD : uint16_t {
     TAG_DELAY_DATA_FLAG,
     TAG_DEVICE_ID,
     TAG_PASTE_ID,
+    TAG_DELAY_RECORD_FLAG,
+    TAG_DATA_ID,
 };
 enum TAG_PROPERTY : uint16_t {
     TAG_ADDITIONS = TAG_BUFF + 1,
@@ -75,7 +77,8 @@ PasteData::~PasteData()
 }
 
 PasteData::PasteData(const PasteData &data) : orginAuthority_(data.orginAuthority_), valid_(data.valid_),
-    isDraggedData_(data.isDraggedData_), isLocalPaste_(data.isLocalPaste_), pasteId_(data.pasteId_)
+    isDraggedData_(data.isDraggedData_), isLocalPaste_(data.isLocalPaste_), pasteId_(data.pasteId_),
+    isDelayData_(data.isDelayData_), isDelayRecord_(data.isDelayRecord_), dataId_(data.dataId_)
 {
     this->props_ = data.props_;
     for (const auto &item : data.records_) {
@@ -100,6 +103,9 @@ PasteData& PasteData::operator=(const PasteData &data)
     this->valid_ = data.valid_;
     this->isDraggedData_ = data.isDraggedData_;
     this->isLocalPaste_ = data.isLocalPaste_;
+    this->isDelayData_ = data.isDelayData_;
+    this->isDelayRecord_ = data.isDelayRecord_;
+    this->dataId_ = data.dataId_;
     this->props_ = data.props_;
     this->records_.clear();
     this->deviceId_ = data.deviceId_;
@@ -155,6 +161,7 @@ void PasteData::AddRecord(std::shared_ptr<PasteDataRecord> record)
     if (record == nullptr) {
         return;
     }
+    record->SetRecordId(++recordId_);
     records_.insert(records_.begin(), std::move(record));
     RefreshMimeProp();
 }
@@ -431,6 +438,8 @@ bool PasteData::Encode(std::vector<std::uint8_t> &buffer)
     ret = Write(buffer, TAG_DELAY_DATA_FLAG, isDelayData_) && ret;
     ret = Write(buffer, TAG_DEVICE_ID, deviceId_) && ret;
     ret = Write(buffer, TAG_PASTE_ID, pasteId_) && ret;
+    ret = Write(buffer, TAG_DELAY_RECORD_FLAG, isDelayRecord_) && ret;
+    ret = Write(buffer, TAG_DATA_ID, dataId_) && ret;
     return ret;
 }
 
@@ -468,6 +477,14 @@ bool PasteData::Decode(const std::vector<std::uint8_t> &buffer)
                 ret = ret && ReadValue(buffer, pasteId_, head);
                 break;
             }
+            case TAG_DELAY_RECORD_FLAG: {
+                ret = ret && ReadValue(buffer, isDelayRecord_, head);
+                break;
+            }
+            case TAG_DATA_ID: {
+                ret = ret && ReadValue(buffer, dataId_, head);
+                break;
+            }
             default:
                 ret = ret && Skip(head.len, buffer.size());
                 break;
@@ -490,6 +507,8 @@ size_t PasteData::Count()
     expectSize += TLVObject::Count(isDelayData_);
     expectSize += TLVObject::Count(deviceId_);
     expectSize += TLVObject::Count(pasteId_);
+    expectSize += TLVObject::Count(isDelayRecord_);
+    expectSize += TLVObject::Count(dataId_);
     return expectSize;
 }
 
@@ -513,6 +532,26 @@ bool PasteData::IsDelayData() const
     return isDelayData_;
 }
 
+void PasteData::SetDelayRecord(bool isDelay)
+{
+    isDelayRecord_ = isDelay;
+}
+
+bool PasteData::IsDelayRecord() const
+{
+    return isDelayRecord_;
+}
+
+void PasteData::SetDataId(uint32_t dataId)
+{
+    dataId_ = dataId;
+}
+
+uint32_t PasteData::GetDataId() const
+{
+    return dataId_;
+}
+
 bool PasteData::Marshalling(Parcel &parcel) const
 {
     std::vector<uint8_t> pasteDataTlv(0);
diff --git a/framework/innerkits/src/paste_data_entry.cpp b/framework/innerkits/src/paste_data_entry.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..bf0713c274a4100bc0a8a264195c9cc882bc0e6f
--- /dev/null
+++ b/framework/innerkits/src/paste_data_entry.cpp
@@ -0,0 +1,408 @@
+/*
+* Copyright (C) 2024 Huawei Device Co., Ltd.
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#include "paste_data_entry.h"
+
+#include "pasteboard_hilog.h"
+#include "pixel_map.h"
+#include "tlv_object.h"
+namespace OHOS {
+namespace MiscServices {
+
+enum TAG_CUSTOMDATA : uint16_t {
+    TAG_ITEM_DATA = TAG_BUFF + 1,
+};
+
+enum TAG_ENTRY : uint16_t {
+    TAG_ENTRY_UTDID = TAG_BUFF + 1,
+    TAG_ENTRY_MIMETYPE,
+    TAG_ENTRY_VALUE,
+};
+
+std::map<std::string, std::vector<uint8_t>> MineCustomData::GetItemData()
+{
+    return this->itemData_;
+}
+
+void MineCustomData::AddItemData(const std::string& mimeType, const std::vector<uint8_t>& arrayBuffer)
+{
+    itemData_.emplace(mimeType, arrayBuffer);
+    PASTEBOARD_HILOGI(PASTEBOARD_MODULE_CLIENT, "itemData_.size = %{public}zu", itemData_.size());
+}
+
+bool MineCustomData::Encode(std::vector<std::uint8_t>& buffer)
+{
+    return Write(buffer, TAG_ITEM_DATA, itemData_);
+}
+
+bool MineCustomData::Decode(const std::vector<std::uint8_t>& buffer)
+{
+    for (; IsEnough();) {
+        TLVHead head{};
+        bool ret = ReadHead(buffer, head);
+        switch (head.tag) {
+            case TAG_ITEM_DATA:
+                ret = ret && ReadValue(buffer, itemData_, head);
+                break;
+            default:
+                ret = ret && Skip(head.len, buffer.size());
+                break;
+        }
+        if (!ret) {
+            return false;
+        }
+    }
+    return true;
+}
+
+size_t MineCustomData::Count()
+{
+    return TLVObject::Count(itemData_);
+}
+
+PasteDataEntry& PasteDataEntry::operator=(const PasteDataEntry& entry)
+{
+    if (this == &entry) {
+        return *this;
+    }
+    this->utdId_ = entry.GetUtdId();
+    this->mimeType_ = entry.GetMimeType();
+    this->value_ = entry.GetValue();
+    return *this;
+}
+
+PasteDataEntry::PasteDataEntry(const std::string& utdId, const EntryValue& value) : utdId_(utdId), value_(value)
+{
+    mimeType_ = CommonUtils::Convert2MimeType(utdId_);
+}
+
+PasteDataEntry::PasteDataEntry(const std::string& utdId, const std::string& mimeType, const EntryValue& value)
+    : utdId_(utdId), mimeType_(std::move(mimeType)), value_(std::move(value))
+{
+}
+
+void PasteDataEntry::SetUtdId(const std::string& utdId)
+{
+    utdId_ = utdId;
+}
+
+std::string PasteDataEntry::GetUtdId() const
+{
+    return utdId_;
+}
+
+void PasteDataEntry::SetMimeType(const std::string& mimeType)
+{
+    mimeType_ = mimeType;
+}
+
+std::string PasteDataEntry::GetMimeType() const
+{
+    return mimeType_;
+}
+
+EntryValue PasteDataEntry::GetValue() const
+{
+    return value_;
+}
+
+void PasteDataEntry::SetValue(const EntryValue& value)
+{
+    value_ = value;
+}
+
+bool PasteDataEntry::Encode(std::vector<std::uint8_t>& buffer)
+{
+    bool ret = Write(buffer, TAG_ENTRY_UTDID, utdId_);
+    ret = ret && Write(buffer, TAG_ENTRY_MIMETYPE, mimeType_);
+    ret = ret && Write(buffer, TAG_ENTRY_VALUE, value_);
+    return ret;
+}
+
+bool PasteDataEntry::Decode(const std::vector<std::uint8_t>& buffer)
+{
+    for (; IsEnough();) {
+        TLVHead head{};
+        bool ret = ReadHead(buffer, head);
+        switch (head.tag) {
+            case TAG_ENTRY_UTDID:
+                ret = ret && ReadValue(buffer, utdId_, head);
+                break;
+            case TAG_ENTRY_MIMETYPE: {
+                ret = ret && ReadValue(buffer, mimeType_, head);
+                break;
+            }
+            case TAG_ENTRY_VALUE: {
+                ret = ret && ReadValue(buffer, value_, head);
+                break;
+            }
+            default:
+                ret = ret && Skip(head.len, buffer.size());
+                break;
+        }
+        PASTEBOARD_HILOGD(PASTEBOARD_MODULE_CLIENT, "read value,tag:%{public}u, len:%{public}u, ret:%{public}d",
+            head.tag, head.len, ret);
+        if (!ret) {
+            return false;
+        }
+    }
+    return true;
+}
+
+bool PasteDataEntry::Marshalling(std::vector<std::uint8_t>& buffer)
+{
+    Init(buffer);
+    return Encode(buffer);
+}
+
+bool PasteDataEntry::Unmarshalling(const std::vector<std::uint8_t>& buffer)
+{
+    total_ = buffer.size();
+    return Decode(buffer);
+}
+
+size_t PasteDataEntry::Count()
+{
+    size_t expectedSize = 0;
+    expectedSize += TLVObject::Count(utdId_);
+    expectedSize += TLVObject::Count(mimeType_);
+    expectedSize += TLVObject::Count(value_);
+    return expectedSize;
+}
+
+std::shared_ptr<std::string> PasteDataEntry::ConvertToPlianText() const
+{
+    std::string res;
+    auto utdId = GetUtdId();
+    auto entry = GetValue();
+    if (std::holds_alternative<std::string>(entry)) {
+        res = std::get<std::string>(entry);
+        return std::make_shared<std::string>(res);
+    }
+    if (!std::holds_alternative<std::shared_ptr<Object>>(entry)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "value error, no plaintext");
+        return nullptr;
+    }
+    auto object = std::get<std::shared_ptr<Object>>(entry);
+    if (utdId == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::PLAIN_TEXT)) {
+        object->GetValue(UDMF::CONTENT, res);
+    } else {
+        object->GetValue(UDMF::URL, res);
+    }
+    return std::make_shared<std::string>(res);
+}
+
+std::shared_ptr<std::string> PasteDataEntry::ConvertToHtml() const
+{
+    std::string res;
+    if (GetUtdId() != UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::HTML)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "type error, utdId:%{public}s", GetUtdId().c_str());
+        return nullptr;
+    }
+    auto entry = GetValue();
+    if (std::holds_alternative<std::string>(entry)) {
+        res = std::get<std::string>(entry);
+        return std::make_shared<std::string>(res);
+    }
+    if (!std::holds_alternative<std::shared_ptr<Object>>(entry)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "value error, no html");
+        return nullptr;
+    }
+    auto object = std::get<std::shared_ptr<Object>>(entry);
+    object->GetValue(UDMF::HTML_CONTENT, res);
+    return std::make_shared<std::string>(res);
+}
+
+std::shared_ptr<Uri> PasteDataEntry::ConvertToUri() const
+{
+    std::string res;
+    if (GetUtdId() != UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::FILE_URI)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "type error, utdId:%{public}s", GetUtdId().c_str());
+        return nullptr;
+    }
+    auto entry = GetValue();
+    if (std::holds_alternative<std::string>(entry)) {
+        res = std::get<std::string>(entry);
+        return std::make_shared<Uri>(Uri(res));
+    }
+    if (!std::holds_alternative<std::shared_ptr<Object>>(entry)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "value error, no uri");
+        return nullptr;
+    }
+    auto object = std::get<std::shared_ptr<Object>>(entry);
+    object->GetValue(UDMF::FILE_URI_PARAM, res);
+    return std::make_shared<Uri>(Uri(res));
+}
+
+std::shared_ptr<AAFwk::Want> PasteDataEntry::ConvertToWant() const
+{
+    if (GetUtdId() != UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::OPENHARMONY_WANT)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "type error, utdId:%{public}s", GetUtdId().c_str());
+        return nullptr;
+    }
+    auto entry = GetValue();
+    if (!std::holds_alternative<std::shared_ptr<AAFwk::Want>>(entry)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "value error, no plaintext");
+        return nullptr;
+    }
+    // no uds want
+    return std::get<std::shared_ptr<AAFwk::Want>>(entry);
+}
+
+std::shared_ptr<Media::PixelMap> PasteDataEntry::ConvertToPixelMap() const
+{
+    auto utdId = GetUtdId();
+    if (utdId != UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::SYSTEM_DEFINED_PIXEL_MAP)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "type error, utdId:%{public}s", utdId.c_str());
+        return nullptr;
+    }
+    auto entry = GetValue();
+    if (std::holds_alternative<std::shared_ptr<Media::PixelMap>>(entry)) {
+        return std::get<std::shared_ptr<Media::PixelMap>>(entry);
+    }
+    if (!std::holds_alternative<std::shared_ptr<Object>>(entry)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "value error, no pixelmap");
+    }
+    auto object = std::get<std::shared_ptr<Object>>(entry);
+    std::string objecType;
+    if (!object->GetValue(UDMF::UNIFORM_DATA_TYPE, objecType)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "type error, utdId:%{public}s", utdId.c_str());
+        return nullptr;
+    }
+    if (objecType != UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::SYSTEM_DEFINED_PIXEL_MAP)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "type error, objecType:%{public}s", objecType.c_str());
+        return nullptr;
+    }
+    auto val = object->value_[UDMF::PIXEL_MAP];
+    if (std::holds_alternative<std::shared_ptr<Media::PixelMap>>(val)) {
+        return std::get<std::shared_ptr<Media::PixelMap>>(val);
+    }
+    PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "value error, no pixelmap");
+    return nullptr;
+}
+
+std::shared_ptr<MineCustomData> PasteDataEntry::ConvertToCustomData() const
+{
+    auto entry = GetValue();
+    MineCustomData customdata;
+    if (std::holds_alternative<std::vector<uint8_t>>(entry)) {
+        customdata.AddItemData(GetMimeType(), std::get<std::vector<uint8_t>>(entry));
+        return std::make_shared<MineCustomData>(customdata);
+    }
+    // deal u8 only, object not surpport
+    if (!std::holds_alternative<std::shared_ptr<Object>>(entry)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "value not surpport, object");
+    }
+    PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "value error,  utdId:%{public}s", GetUtdId().c_str());
+    return nullptr;
+}
+
+std::string CommonUtils::Convert(UDType uDType)
+{
+    switch (uDType) {
+        case UDType::PLAIN_TEXT:
+        case UDType::HYPERLINK:
+            return MIMETYPE_TEXT_PLAIN;
+        case UDType::HTML:
+            return MIMETYPE_TEXT_HTML;
+        case UDType::FILE:
+        case UDType::IMAGE:
+        case UDType::VIDEO:
+        case UDType::AUDIO:
+        case UDType::FOLDER:
+        case UDType::FILE_URI:
+            return MIMETYPE_TEXT_URI;
+        case UDType::SYSTEM_DEFINED_PIXEL_MAP:
+            return MIMETYPE_PIXELMAP;
+        case UDType::OPENHARMONY_WANT:
+            return MIMETYPE_TEXT_WANT;
+        default:
+            return UDMF::UtdUtils::GetUtdIdFromUtdEnum(uDType);
+    }
+}
+
+std::string CommonUtils::Convert2MimeType(const std::string& utdId)
+{
+    if (utdId == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::PLAIN_TEXT) ||
+        utdId == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::HYPERLINK)) {
+        return MIMETYPE_TEXT_PLAIN;
+    }
+    if (utdId == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::HTML)) {
+        return MIMETYPE_TEXT_HTML;
+    }
+    if (utdId == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::FILE_URI)) {
+        return MIMETYPE_TEXT_URI;
+    }
+    if (utdId == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::SYSTEM_DEFINED_PIXEL_MAP)) {
+        return MIMETYPE_PIXELMAP;
+    }
+    if (utdId == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::OPENHARMONY_WANT)) {
+        return MIMETYPE_TEXT_WANT;
+    }
+    return utdId;
+}
+
+// other is appdefined-types
+std::string CommonUtils::Convert2UtdId(int32_t uDType, const std::string& mimeType)
+{
+    if (mimeType == MIMETYPE_TEXT_PLAIN && uDType == UDMF::HYPERLINK) {
+        return UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::HYPERLINK);
+    }
+    if (mimeType == MIMETYPE_TEXT_PLAIN) {
+        return UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::PLAIN_TEXT);
+    }
+    if (mimeType == MIMETYPE_TEXT_URI) {
+        return UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::FILE_URI);
+    }
+    if (mimeType == MIMETYPE_TEXT_HTML) {
+        return UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::HTML);
+    }
+    if (mimeType == MIMETYPE_TEXT_WANT) {
+        return UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::OPENHARMONY_WANT);
+    }
+    if (mimeType == MIMETYPE_PIXELMAP) {
+        return UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDType::SYSTEM_DEFINED_PIXEL_MAP);
+    }
+    return mimeType;
+}
+
+UDMF::UDType CommonUtils::Convert(int32_t uDType, const std::string& mimeType)
+{
+    if (uDType != UDMF::UD_BUTT) {
+        return static_cast<UDType>(uDType);
+    }
+    if (mimeType == MIMETYPE_TEXT_URI) {
+        return UDMF::FILE_URI;
+    }
+    if (mimeType == MIMETYPE_TEXT_PLAIN) {
+        return UDMF::PLAIN_TEXT;
+    }
+    if (mimeType == MIMETYPE_TEXT_HTML) {
+        return UDMF::HTML;
+    }
+    if (mimeType == MIMETYPE_TEXT_WANT) {
+        return UDMF::OPENHARMONY_WANT;
+    }
+    if (mimeType == MIMETYPE_PIXELMAP) {
+        return UDMF::SYSTEM_DEFINED_PIXEL_MAP;
+    }
+    auto type = UDMF::UtdUtils::GetUtdEnumFromUtdId(mimeType);
+    if (type != UDMF::UD_BUTT) {
+        return static_cast<UDType>(type);
+    }
+    return UDMF::APPLICATION_DEFINED_RECORD;
+}
+} // namespace MiscServices
+} // namespace OHOS
\ No newline at end of file
diff --git a/framework/innerkits/src/paste_data_record.cpp b/framework/innerkits/src/paste_data_record.cpp
index 8c48ff089a4d3744018d26b3a47cbc254dd3085c..c408167aa77eddc27c72e2778be63720d23e2c6d 100644
--- a/framework/innerkits/src/paste_data_record.cpp
+++ b/framework/innerkits/src/paste_data_record.cpp
@@ -17,10 +17,9 @@
 #include <sys/stat.h>
 #include <unistd.h>
 
+#include "convert_utils.h"
 #include "copy_uri_handler.h"
 #include "parcel_util.h"
-#include "paste_uri_handler.h"
-#include "pasteboard_error.h"
 #include "pasteboard_hilog.h"
 #include "pixel_map_parcel.h"
 
@@ -31,7 +30,6 @@ namespace MiscServices {
 namespace {
 constexpr int MAX_TEXT_LEN = 20 * 1024 * 1024;
 }
-
 PasteDataRecord::Builder &PasteDataRecord::Builder::SetMimeType(std::string mimeType)
 {
     record_->mimeType_ = std::move(mimeType);
@@ -51,10 +49,11 @@ enum TAG_PASTEBOARD_RECORD : uint16_t {
     TAG_UDC_DETAILS,
     TAG_UDC_TEXTCONTENT,
     TAG_UDC_SYSTEMCONTENTS,
-};
-
-enum TAG_CUSTOMDATA : uint16_t {
-    TAG_ITEM_DATA = TAG_BUFF + 1,
+    TAG_UDC_UDMFVALUE,
+    TAG_UDC_ENTYIES,
+    TAG_DATA_ID,
+    TAG_RECORD_ID,
+    TAG_DELAY_RECORD_FLAG,
 };
 
 PasteDataRecord::Builder &PasteDataRecord::Builder::SetHtmlText(std::shared_ptr<std::string> htmlText)
@@ -62,11 +61,13 @@ PasteDataRecord::Builder &PasteDataRecord::Builder::SetHtmlText(std::shared_ptr<
     record_->htmlText_ = std::move(htmlText);
     return *this;
 }
-PasteDataRecord::Builder &PasteDataRecord::Builder::SetWant(std::shared_ptr<OHOS::AAFwk::Want> want)
+
+PasteDataRecord::Builder& PasteDataRecord::Builder::SetWant(std::shared_ptr<OHOS::AAFwk::Want> want)
 {
     record_->want_ = std::move(want);
     return *this;
 }
+
 PasteDataRecord::Builder &PasteDataRecord::Builder::SetPlainText(std::shared_ptr<std::string> plainText)
 {
     record_->plainText_ = std::move(plainText);
@@ -77,6 +78,7 @@ PasteDataRecord::Builder &PasteDataRecord::Builder::SetUri(std::shared_ptr<OHOS:
     record_->uri_ = std::move(uri);
     return *this;
 }
+
 PasteDataRecord::Builder &PasteDataRecord::Builder::SetPixelMap(std::shared_ptr<OHOS::Media::PixelMap> pixelMap)
 {
     record_->pixelMap_ = std::move(pixelMap);
@@ -93,6 +95,7 @@ std::shared_ptr<PasteDataRecord> PasteDataRecord::Builder::Build()
 {
     return record_;
 }
+
 PasteDataRecord::Builder::Builder(const std::string &mimeType)
 {
     record_ = std::make_shared<PasteDataRecord>();
@@ -108,6 +111,17 @@ PasteDataRecord::Builder::Builder(const std::string &mimeType)
     }
 }
 
+void PasteDataRecord::AddUriEntry()
+{
+    auto object = std::make_shared<Object>();
+    object->value_[UDMF::UNIFORM_DATA_TYPE] = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::FILE_URI);
+    if (uri_ != nullptr) {
+        object->value_[UDMF::FILE_URI_PARAM] = uri_->ToString();
+    }
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::FILE_URI);
+    AddEntry(utdId, std::make_shared<PasteDataEntry>(utdId, object));
+}
+
 std::shared_ptr<PasteDataRecord> PasteDataRecord::NewHtmlRecord(const std::string &htmlText)
 {
     if (htmlText.length() >= MAX_TEXT_LEN) {
@@ -170,7 +184,8 @@ PasteDataRecord::PasteDataRecord(const PasteDataRecord& record)
       uri_(record.uri_), convertUri_(record.convertUri_), pixelMap_(record.pixelMap_), customData_(record.customData_),
       hasGrantUriPermission_(record.hasGrantUriPermission_), fd_(record.fd_), udType_(record.udType_),
       details_(record.details_), textContent_(record.textContent_),
-      systemDefinedContents_(record.systemDefinedContents_)
+      systemDefinedContents_(record.systemDefinedContents_), udmfValue_(record.udmfValue_), entries_(record.entries_),
+      dataId_(record.dataId_), recordId_(record.recordId_), isDelay_(record.isDelay_)
 {
     this->isConvertUriFromRemote = record.isConvertUriFromRemote;
     InitDecodeMap();
@@ -217,6 +232,16 @@ void PasteDataRecord::InitDecodeMap()
             ret = ret && ReadValue(buffer, textContent_, head);}},
         {TAG_UDC_SYSTEMCONTENTS, [&](bool &ret, const std::vector<std::uint8_t> &buffer, TLVHead &head) -> void {
             ret = ret && ReadValue(buffer, systemDefinedContents_, head);}},
+        {TAG_UDC_UDMFVALUE, [&](bool &ret, const std::vector<std::uint8_t> &buffer, TLVHead &head) -> void {
+            ret = ret && ReadValue(buffer, udmfValue_, head);}},
+        {TAG_UDC_ENTYIES, [&](bool &ret, const std::vector<std::uint8_t> &buffer, TLVHead &head) -> void {
+            ret = ret && ReadValue(buffer, entries_, head);}},
+        {TAG_DATA_ID, [&](bool &ret, const std::vector<std::uint8_t> &buffer, TLVHead &head) -> void {
+            ret = ret && ReadValue(buffer, dataId_, head);}},
+        {TAG_RECORD_ID, [&](bool &ret, const std::vector<std::uint8_t> &buffer, TLVHead &head) -> void {
+            ret = ret && ReadValue(buffer, recordId_, head);}},
+        {TAG_DELAY_RECORD_FLAG, [&](bool &ret, const std::vector<std::uint8_t> &buffer, TLVHead &head) -> void {
+            ret = ret && ReadValue(buffer, isDelay_, head);}},
     };
 }
 
@@ -243,7 +268,7 @@ std::shared_ptr<PixelMap> PasteDataRecord::GetPixelMap() const
 std::shared_ptr<OHOS::Uri> PasteDataRecord::GetUri() const
 {
     if (convertUri_.empty()) {
-        return uri_;
+        return GetOrginUri();
     }
     return std::make_shared<OHOS::Uri>(convertUri_);
 }
@@ -256,11 +281,20 @@ void PasteDataRecord::ClearPixelMap()
 void PasteDataRecord::SetUri(std::shared_ptr<OHOS::Uri> uri)
 {
     uri_ = std::move(uri);
+    AddUriEntry();
 }
 
 std::shared_ptr<OHOS::Uri> PasteDataRecord::GetOrginUri() const
 {
-    return uri_;
+    if (uri_) {
+        return uri_;
+    }
+    for (auto const& entry: entries_) {
+        if (entry && entry->GetMimeType() == MIMETYPE_TEXT_URI) {
+            return entry->ConvertToUri();
+        }
+    }
+    return nullptr;
 }
 
 std::shared_ptr<OHOS::AAFwk::Want> PasteDataRecord::GetWant() const
@@ -273,17 +307,6 @@ std::shared_ptr<MineCustomData> PasteDataRecord::GetCustomData() const
     return this->customData_;
 }
 
-std::map<std::string, std::vector<uint8_t>> MineCustomData::GetItemData()
-{
-    return this->itemData_;
-}
-
-void MineCustomData::AddItemData(const std::string &mimeType, const std::vector<uint8_t> &arrayBuffer)
-{
-    itemData_.insert(std::make_pair(mimeType, arrayBuffer));
-    PASTEBOARD_HILOGI(PASTEBOARD_MODULE_CLIENT, "itemData_.size = %{public}zu", itemData_.size());
-}
-
 std::string PasteDataRecord::ConvertToText() const
 {
     if (this->htmlText_) {
@@ -297,36 +320,6 @@ std::string PasteDataRecord::ConvertToText() const
     }
 }
 
-bool MineCustomData::Encode(std::vector<std::uint8_t> &buffer)
-{
-    return TLVObject::Write(buffer, TAG_ITEM_DATA, itemData_);
-}
-
-bool MineCustomData::Decode(const std::vector<std::uint8_t> &buffer)
-{
-    for (; IsEnough();) {
-        TLVHead head{};
-        bool ret = ReadHead(buffer, head);
-        switch (head.tag) {
-            case TAG_ITEM_DATA:
-                ret = ret && ReadValue(buffer, itemData_, head);
-                break;
-            default:
-                ret = ret && Skip(head.len, buffer.size());
-                break;
-        }
-        if (!ret) {
-            return false;
-        }
-    }
-    return true;
-}
-
-size_t MineCustomData::Count()
-{
-    return TLVObject::Count(itemData_);
-}
-
 bool PasteDataRecord::Encode(std::vector<std::uint8_t> &buffer)
 {
     bool ret = Write(buffer, TAG_MIMETYPE, mimeType_);
@@ -343,6 +336,11 @@ bool PasteDataRecord::Encode(std::vector<std::uint8_t> &buffer)
     ret = Write(buffer, TAG_UDC_DETAILS, details_) && ret;
     ret = Write(buffer, TAG_UDC_TEXTCONTENT, textContent_) && ret;
     ret = Write(buffer, TAG_UDC_SYSTEMCONTENTS, systemDefinedContents_) && ret;
+    ret = Write(buffer, TAG_UDC_UDMFVALUE, udmfValue_) && ret;
+    ret = Write(buffer, TAG_UDC_ENTYIES, entries_) && ret;
+    ret = Write(buffer, TAG_DATA_ID, dataId_) && ret;
+    ret = Write(buffer, TAG_RECORD_ID, recordId_) && ret;
+    ret = Write(buffer, TAG_DELAY_RECORD_FLAG, isDelay_) && ret;
     return ret;
 }
 
@@ -366,6 +364,7 @@ bool PasteDataRecord::Decode(const std::vector<std::uint8_t> &buffer)
     }
     return true;
 }
+
 size_t PasteDataRecord::Count()
 {
     size_t expectedSize = 0;
@@ -383,32 +382,14 @@ size_t PasteDataRecord::Count()
     expectedSize += TLVObject::Count(details_);
     expectedSize += TLVObject::Count(textContent_);
     expectedSize += TLVObject::Count(systemDefinedContents_);
+    expectedSize += TLVObject::Count(udmfValue_);
+    expectedSize += TLVObject::Count(entries_);
+    expectedSize += TLVObject::Count(dataId_);
+    expectedSize += TLVObject::Count(recordId_);
+    expectedSize += TLVObject::Count(isDelay_);
     return expectedSize;
 }
 
-std::shared_ptr<PixelMap> PasteDataRecord::Vector2PixelMap(std::vector<std::uint8_t> &value)
-{
-    PASTEBOARD_HILOGD(PASTEBOARD_MODULE_CLIENT, "Vector2PixelMap, size is %{public}zu", value.size());
-    if (value.size() == 0) {
-        return nullptr;
-    }
-    return std::shared_ptr<PixelMap> (PixelMap::DecodeTlv(value));
-}
-
-std::vector<std::uint8_t> PasteDataRecord::PixelMap2Vector(std::shared_ptr<PixelMap> &pixelMap)
-{
-    PASTEBOARD_HILOGD(PASTEBOARD_MODULE_CLIENT, "PixelMap2Vector");
-    if (pixelMap == nullptr) {
-        return {};
-    }
-    std::vector<std::uint8_t> value;
-    if (!pixelMap->EncodeTlv(value)) {
-        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "pixelMap encode failed");
-        return {};
-    }
-    return value;
-}
-
 bool PasteDataRecord::WriteFd(MessageParcel &parcel, UriHandler &uriHandler, bool isClient)
 {
     PASTEBOARD_HILOGD(PASTEBOARD_MODULE_CLIENT, "isClient: %{public}d", isClient);
@@ -427,6 +408,7 @@ bool PasteDataRecord::WriteFd(MessageParcel &parcel, UriHandler &uriHandler, boo
     PASTEBOARD_HILOGD(PASTEBOARD_MODULE_CLIENT, "ret is %{public}d", ret);
     return ret;
 }
+
 bool PasteDataRecord::ReadFd(MessageParcel &parcel, UriHandler &uriHandler)
 {
     int32_t fd = parcel.ReadFileDescriptor();
@@ -463,6 +445,7 @@ std::string PasteDataRecord::GetPassUri()
     }
     return tempUri;
 }
+
 void PasteDataRecord::ReplaceShareUri(int32_t userId)
 {
     if (convertUri_.empty()) {
@@ -498,6 +481,7 @@ void PasteDataRecord::SetTextContent(const std::string& content)
 {
     this->textContent_ = content;
 }
+
 std::string PasteDataRecord::GetTextContent() const
 {
     return this->textContent_;
@@ -532,6 +516,150 @@ void PasteDataRecord::SetUDType(int32_t type)
     this->udType_ = type;
 }
 
+std::vector<std::string> PasteDataRecord::GetValidTypes(const std::vector<std::string>& types) const
+{
+    std::vector<std::string> res;
+    auto allTypes = GetUdtTypes();
+    for (auto const& type : types) {
+        if (allTypes.find(type) != allTypes.end()) {
+            res.emplace_back(type);
+        }
+    }
+    return res;
+}
+
+bool PasteDataRecord::IsEmpty() const
+{
+    if (udmfValue_ && !std::holds_alternative<std::monostate>(*udmfValue_)) {
+        return false;
+    }
+    for (auto const& entry : entries_) {
+        if (!std::holds_alternative<std::monostate>(entry->GetValue())) {
+            return false;
+        }
+    }
+    return true;
+}
+
+void PasteDataRecord::SetUDMFValue(const std::shared_ptr<EntryValue>& udmfValue)
+{
+    this->udmfValue_ = udmfValue;
+}
+
+std::shared_ptr<EntryValue> PasteDataRecord::GetUDMFValue() const
+{
+    return this->udmfValue_;
+}
+
+std::set<std::string> PasteDataRecord::GetUdtTypes() const
+{
+    std::set<std::string> types;
+    types.emplace(CommonUtils::Convert2UtdId(udType_, mimeType_));
+    for (auto const& entry: entries_) {
+        types.emplace(entry->GetUtdId());
+    }
+    return types;
+}
+
+void PasteDataRecord::AddEntry(const std::string& utdType, std::shared_ptr<PasteDataEntry> value)
+{
+    if (!value) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "entry is null");
+        return;
+    }
+    if (utdType != value->GetUtdId()) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "type is diff. utdtype:%{public}s, UtdId:%{public}s",
+            utdType.c_str(), value->GetUtdId().c_str());
+        return;
+    }
+    // first entry save to record, or record type same
+    if (mimeType_.empty() || utdType == CommonUtils::Convert2UtdId(udType_, mimeType_)) {
+        mimeType_ = value->GetMimeType();
+        auto udType = UDMF::UtdUtils::GetUtdEnumFromUtdId(utdType);
+        udType_ = udType == UDMF::UDType::UD_BUTT ? UDMF::UDType::APPLICATION_DEFINED_RECORD : udType;
+        udmfValue_ =std::make_shared<EntryValue>(value->GetValue());
+        if (mimeType_ == MIMETYPE_PIXELMAP) {
+            pixelMap_ = value->ConvertToPixelMap();
+        } else if (mimeType_ == MIMETYPE_TEXT_HTML) {
+            htmlText_ = value->ConvertToHtml();
+        } else if (mimeType_ == MIMETYPE_TEXT_PLAIN) {
+            plainText_ = value->ConvertToPlianText();
+        } else if (mimeType_ == MIMETYPE_TEXT_URI) {
+            uri_ = value->ConvertToUri();
+        } else if (mimeType_ == MIMETYPE_TEXT_WANT) {
+            want_ = value->ConvertToWant();
+        } else {
+            customData_ = value->ConvertToCustomData();
+        }
+        return;
+    }
+    // not firest entry
+    bool has = false;
+    for (auto& entry : entries_) {
+        if (entry->GetUtdId() == utdType) {
+            entry = value;
+            has = true;
+            break;
+        }
+    }
+    if (!has) {
+        entries_.emplace_back(value);
+    }
+}
+
+std::shared_ptr<PasteDataEntry> PasteDataRecord::GetEntry(const std::string& utdType) const
+{
+    if (udmfValue_ && CommonUtils::Convert2UtdId(udType_, mimeType_) == utdType) {
+        return std::make_shared<PasteDataEntry>(utdType, *udmfValue_);
+    }
+    for (auto const& entry : entries_) {
+        if (entry->GetUtdId() == utdType) {
+            return entry;
+        }
+    }
+    return nullptr;
+}
+
+std::vector<std::shared_ptr<PasteDataEntry>> PasteDataRecord::GetEntries() const
+{
+    std::vector<std::shared_ptr<PasteDataEntry>> entries = entries_;
+    if (udmfValue_) {
+        entries.insert(entries.begin(),
+            std::make_shared<PasteDataEntry>(CommonUtils::Convert2UtdId(udType_, mimeType_), *udmfValue_));
+    }
+    return entries;
+}
+
+void PasteDataRecord::SetDataId(uint32_t dataId)
+{
+    dataId_ = dataId;
+}
+
+uint32_t PasteDataRecord::GetDataId() const
+{
+    return dataId_;
+}
+
+void PasteDataRecord::SetRecordId(uint32_t recordId)
+{
+    recordId_ = recordId;
+}
+
+uint32_t PasteDataRecord::GetRecordId() const
+{
+    return recordId_;
+}
+
+void PasteDataRecord::SetDelayRecordFlag(bool isDelay)
+{
+    isDelay_ = isDelay;
+}
+
+bool PasteDataRecord::IsDelayRecord() const
+{
+    return isDelay_;
+}
+
 FileDescriptor::~FileDescriptor()
 {
     if (fd_ >= 0) {
diff --git a/framework/innerkits/src/pasteboard_client.cpp b/framework/innerkits/src/pasteboard_client.cpp
index 00cd55b26ad5ad617f0eb28d38b37cac5411373b..2c2db49e9bee784d36fa73f5605c2daa60390143 100644
--- a/framework/innerkits/src/pasteboard_client.cpp
+++ b/framework/innerkits/src/pasteboard_client.cpp
@@ -17,7 +17,7 @@
 #include <ipc_skeleton.h>
 #include <iservice_registry.h>
 #include <chrono>
-
+#include "convert_utils.h"
 #include "file_uri.h"
 #include "hiview_adapter.h"
 #include "hitrace_meter.h"
@@ -191,6 +191,14 @@ std::shared_ptr<PasteData> PasteboardClient::CreateKvData(
     return pasteData;
 }
 
+int32_t PasteboardClient::GetRecordValueByType(uint32_t dataId, uint32_t recordId, PasteDataEntry &value)
+{
+    auto proxyService = GetPasteboardService();
+    if (proxyService == nullptr) {
+        return static_cast<int32_t>(PasteboardError::E_SA_DIED);
+    }
+    return proxyService->GetRecordValueByType(dataId, recordId, value);
+}
 void PasteboardClient::Clear()
 {
     PASTEBOARD_HILOGD(PASTEBOARD_MODULE_CLIENT, "Clear start.");
@@ -261,6 +269,16 @@ int32_t PasteboardClient::GetUnifiedData(UDMF::UnifiedData& unifiedData)
     return ret;
 }
 
+int32_t PasteboardClient::GetUdsdData(UDMF::UnifiedData &unifiedData)
+{
+    StartAsyncTrace(HITRACE_TAG_MISC, "PasteboardClient::GetUdsdData", HITRACE_GETPASTEDATA);
+    PasteData pasteData;
+    int32_t ret = GetPasteData(pasteData);
+    unifiedData = *(ConvertUtils::Convert(pasteData));
+    FinishAsyncTrace(HITRACE_TAG_MISC, "PasteboardClient::GetUdsdData", HITRACE_GETPASTEDATA);
+    return ret;
+}
+
 void PasteboardClient::RebuildWebviewPasteData(PasteData &pasteData)
 {
     if (pasteData.GetTag() != PasteData::WEBVIEW_PASTEDATA_TAG || pasteData.GetPrimaryHtml() == nullptr) {
@@ -332,7 +350,8 @@ bool PasteboardClient::HasPasteData()
     return proxyService->HasPasteData();
 }
 
-int32_t PasteboardClient::SetPasteData(PasteData &pasteData, std::shared_ptr<PasteboardDelayGetter> delayGetter)
+int32_t PasteboardClient::SetPasteData(PasteData &pasteData, std::shared_ptr <PasteboardDelayGetter> delayGetter,
+                                       std::map <uint32_t, std::shared_ptr<UDMF::EntryGetter>> entryGetters)
 {
     PASTEBOARD_HILOGD(PASTEBOARD_MODULE_CLIENT, "SetPasteData start.");
     RADAR_REPORT(RadarReporter::DFX_SET_PASTEBOARD, RadarReporter::DFX_SET_BIZ_SCENE, RadarReporter::DFX_SUCCESS,
@@ -349,16 +368,21 @@ int32_t PasteboardClient::SetPasteData(PasteData &pasteData, std::shared_ptr<Pas
         pasteData.SetDelayData(true);
         delayGetterAgent = new (std::nothrow) PasteboardDelayGetterClient(delayGetter);
     }
+    sptr <PasteboardEntryGetterClient> entryGetterAgent;
+    if (!(entryGetters.empty())) {
+        pasteData.SetDelayRecord(true);
+        entryGetterAgent = new(std::nothrow) PasteboardEntryGetterClient(entryGetters);
+    }
     std::shared_ptr<std::string> html = pasteData.GetPrimaryHtml();
     if (pasteData.GetTag() != PasteData::WEBVIEW_PASTEDATA_TAG || html == nullptr) {
-        auto noHtmlRet = proxyService->SetPasteData(pasteData, delayGetterAgent);
+        auto noHtmlRet = proxyService->SetPasteData(pasteData, delayGetterAgent, entryGetterAgent);
         return noHtmlRet;
     }
     auto webData = SplitWebviewPasteData(pasteData);
     if (webData == nullptr) {
         return static_cast<int32_t>(PasteboardError::E_INVALID_VALUE);
     }
-    auto ret = proxyService->SetPasteData(*webData, delayGetterAgent);
+    auto ret = proxyService->SetPasteData(*webData, delayGetterAgent, entryGetterAgent);
     if (ret == static_cast<int32_t>(PasteboardError::E_OK)) {
         RADAR_REPORT(RadarReporter::DFX_SET_PASTEBOARD, RadarReporter::DFX_SET_BIZ_SCENE, RadarReporter::DFX_SUCCESS,
             RadarReporter::BIZ_STATE, RadarReporter::DFX_END);
@@ -381,6 +405,18 @@ int32_t PasteboardClient::SetUnifiedData(const UDMF::UnifiedData &unifiedData,
     return SetPasteData(*pasteData, delayGetter);
 }
 
+int32_t PasteboardClient::SetUdsdData(const UDMF::UnifiedData &unifiedData)
+{
+    auto pasteData = ConvertUtils::Convert(unifiedData);
+    std::map <uint32_t, std::shared_ptr<UDMF::EntryGetter>> entryGetters;
+    for (auto record : unifiedData.GetRecords()) {
+        if (record != nullptr && record->GetEntryGetter() != nullptr) {
+            entryGetters.emplace(record->GetRecordId(), record->GetEntryGetter());
+        }
+    }
+    return SetPasteData(*pasteData, nullptr, entryGetters);
+}
+
 std::shared_ptr<PasteData> PasteboardClient::SplitWebviewPasteData(PasteData &pasteData)
 {
     PASTEBOARD_HILOGD(PASTEBOARD_MODULE_CLIENT, "SplitWebviewPasteData start.");
diff --git a/framework/innerkits/src/pasteboard_entry_getter.cpp b/framework/innerkits/src/pasteboard_entry_getter.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..7b23266bb25a891cabe45ea2c0ae580813ad6820
--- /dev/null
+++ b/framework/innerkits/src/pasteboard_entry_getter.cpp
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "pasteboard_client.h"
+#include "pasteboard_error.h"
+#include "pasteboard_entry_getter.h"
+#include "pasteboard_hilog.h"
+
+namespace OHOS {
+namespace MiscServices {
+using namespace OHOS::UDMF;
+__attribute__((used)) PasteboardEntryGetter::Factory PasteboardEntryGetter::factory_;
+PasteboardEntryGetter::Factory::Factory()
+{
+    GetterSystem::GetInstance().RegisterCreator("pasteboard", [this]() {
+        if (getter_ == nullptr) {
+            getter_ = std::make_shared<PasteboardEntryGetter>();
+        }
+        return getter_;
+    });
+}
+
+PasteboardEntryGetter::Factory::~Factory()
+{
+    getter_ = nullptr;
+}
+
+UDMF::ValueType PasteboardEntryGetter::GetValueByType(uint32_t dataId, uint32_t recordId, const std::string &utdId)
+{
+    PASTEBOARD_HILOGI(PASTEBOARD_MODULE_CLIENT, "dataId:%{public}d. recordId:%{public}d, utdId:%{public}s",
+        dataId, recordId, utdId.c_str());
+    auto pasteType = CommonUtils::Convert2MimeType(utdId);
+    PasteDataEntry entryValue;
+    entryValue.SetUtdId(utdId);
+    entryValue.SetMimeType(pasteType);
+    auto result = PasteboardClient::GetInstance()->GetRecordValueByType(dataId, recordId, entryValue);
+    if (result != static_cast<int32_t>(PasteboardError::E_OK)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "get entry value fail, result:%{public}d", result);
+    }
+    return entryValue.GetValue();
+}
+} // namespace MiscServices
+} // namespace OHOS
\ No newline at end of file
diff --git a/framework/innerkits/src/pasteboard_utils.cpp b/framework/innerkits/src/pasteboard_utils.cpp
index 31694fe8736688542460fca534632b10981af23b..fb53a213ed885139c0e8d915bd551c48702c237c 100644
--- a/framework/innerkits/src/pasteboard_utils.cpp
+++ b/framework/innerkits/src/pasteboard_utils.cpp
@@ -27,6 +27,8 @@
 #include "system_defined_form.h"
 #include "unified_record.h"
 #include "video.h"
+#include "system_defined_pixelmap.h"
+
 namespace OHOS {
 namespace MiscServices {
 using UnifiedRecord = UDMF::UnifiedRecord;
@@ -78,7 +80,7 @@ std::shared_ptr<PasteData> PasteboardUtils::Convert(const UnifiedData& unifiedDa
     auto pasteData = std::make_shared<PasteData>(Convert(unifiedRecords));
     auto unifiedDataProperties = unifiedData.GetProperties();
     auto properties = Convert(*unifiedDataProperties);
-    auto recordTypes = unifiedData.GetUDTypes();
+    auto recordTypes = unifiedData.GetTypesLabels();
     properties.mimeTypes = Convert(recordTypes);
     pasteData->SetProperty(properties);
     return pasteData;
@@ -149,11 +151,11 @@ std::shared_ptr<UnifiedDataProperties> PasteboardUtils::Convert(const PasteDataP
     return unifiedDataProperties;
 }
 
-std::vector<std::string> PasteboardUtils::Convert(const std::vector<UDType>& uDTypes)
+std::vector<std::string> PasteboardUtils::Convert(const std::vector<std::string>& utdIds)
 {
     std::vector<std::string> types;
-    for (const auto& udType : uDTypes) {
-        types.push_back(Convert(udType));
+    for (const auto& utdId : utdIds) {
+        types.push_back(CommonUtils::Convert2MimeType(utdId));
     }
     return types;
 }
@@ -512,7 +514,7 @@ std::shared_ptr<UnifiedRecord> PasteboardUtils::PasteRecord2Folder(const std::sh
 
 std::shared_ptr<PasteDataRecord> PasteboardUtils::PixelMap2PasteRecord(const std::shared_ptr<UnifiedRecord> record)
 {
-    auto pixelMap = static_cast<UDMF::UnifiedRecord*>(record.get());
+    auto pixelMap = static_cast<UDMF::SystemDefinedPixelMap*>(record.get());
     if (pixelMap == nullptr) {
         PASTEBOARD_HILOGD(PASTEBOARD_MODULE_CLIENT, "get pixelMap record field.");
         return nullptr;
diff --git a/framework/test/BUILD.gn b/framework/test/BUILD.gn
index dc6806e8d5b57ddd44a1dfd5b1c7ad692d32fefb..ce9bfb1a8dde05a6c4c49ae77b6f3af689e2af7c 100644
--- a/framework/test/BUILD.gn
+++ b/framework/test/BUILD.gn
@@ -44,11 +44,15 @@ ohos_unittest("PasteboardFrameworkTest") {
   sources = [
     "${pasteboard_root_path}/framework/framework/serializable/serializable.cpp",
     "${pasteboard_service_path}/load/src/config.cpp",
+    "src/convert_utils_test.cpp",
     "src/dm_adapter_test.cpp",
     "src/event_center_test.cpp",
+    "src/paste_data_entry_test.cpp",
+    "src/paste_data_record_test.cpp",
     "src/paste_data_test.cpp",
     "src/pasteboard_client_test.cpp",
     "src/pasteboard_client_udmf_delay_test.cpp",
+    "src/pasteboard_multi_type_unified_data_delay_test.cpp",
     "src/pasteboard_unified_data_test.cpp",
     "src/pasteboard_utils_test.cpp",
     "src/serializable_test.cpp",
diff --git a/framework/test/src/convert_utils_test.cpp b/framework/test/src/convert_utils_test.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..ff910b1a235954f12dd04f7ac85aea0e74084f3b
--- /dev/null
+++ b/framework/test/src/convert_utils_test.cpp
@@ -0,0 +1,494 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "convert_utils.h"
+
+#include <gtest/gtest.h>
+#include <paste_data.h>
+#include <unified_data.h>
+
+#include "paste_data_entry.h"
+#include "tlv_object.h"
+#include "unified_meta.h"
+
+namespace OHOS::MiscServices {
+using namespace testing::ext;
+using namespace testing;
+using namespace OHOS::Media;
+class ConvertUtilsTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+
+protected:
+    std::string text_ = "test";
+    std::string extraText_ = "extr";
+    std::string uri_ = "";
+    std::string html_ = "<div class='disable'>helloWorld</div>";
+    std::string link_ = "http://abc.com";
+    std::string appUtdId1_ = "appdefined-mytype1";
+    std::string appUtdId2_ = "appdefined-mytype2";
+    std::vector<uint8_t> rawData1_ = { 1, 2, 3, 4, 5, 6, 7, 8 };
+    std::vector<uint8_t> rawData2_ = { 1, 2, 3, 4, 5, 6, 7, 8 ,9};
+
+    void CheckEntries(const std::vector<std::shared_ptr<PasteDataEntry>>& entries);
+    void CheckPlainUds(const std::shared_ptr<PasteDataEntry> entry);
+    void CheckFileUriUds(const std::shared_ptr<PasteDataEntry> entry);
+    void CheckPixelMapUds(const std::shared_ptr<PasteDataEntry> entry);
+    void CheckHtmlUds(const std::shared_ptr<PasteDataEntry> entry);
+    void CheckLinkUds(const std::shared_ptr<PasteDataEntry> entry);
+    void CheckCustomEntry(const std::shared_ptr<PasteDataEntry> entry);
+
+    void InitDataWithEntries(UDMF::UnifiedData& data);
+    void InitDataWithPlainEntry(UDMF::UnifiedData& data);
+    void InitDataWithHtmlEntry(UDMF::UnifiedData& data);
+    void InitDataWithFileUriEntry(UDMF::UnifiedData& data);
+    void InitDataWithPixelMapEntry(UDMF::UnifiedData& data);
+    void InitDataWitCustomEntry(UDMF::UnifiedData& data);
+    void InitDataWitSameCustomEntry(UDMF::UnifiedData& data);
+
+    void AddPlainUdsEntry(UDMF::UnifiedRecord& record);
+    void AddFileUriUdsEntry(UDMF::UnifiedRecord& record);
+    void AddHtmlUdsEntry(UDMF::UnifiedRecord& record);
+    void AddPixelMapUdsEntry(UDMF::UnifiedRecord& record);
+    void AddLinkUdsEntry(UDMF::UnifiedRecord& record);
+    void AddCustomEntry(UDMF::UnifiedRecord& record);
+    void AddCustomEntries(UDMF::UnifiedRecord& record);
+
+    static PasteData TlvData(const std::shared_ptr<PasteData>& data);
+};
+
+void ConvertUtilsTest::SetUpTestCase(void) {}
+
+void ConvertUtilsTest::TearDownTestCase(void) {}
+
+void ConvertUtilsTest::SetUp(void) {}
+
+void ConvertUtilsTest::TearDown(void) {}
+
+PasteData ConvertUtilsTest::TlvData(const std::shared_ptr<PasteData>& data)
+{
+    std::vector<std::uint8_t> buffer;
+    data->Init(buffer);
+    data->Encode(buffer);
+    PasteData decodePasteData;
+    decodePasteData.Decode(buffer);
+    return decodePasteData;
+}
+
+void ConvertUtilsTest::AddPlainUdsEntry(UDMF::UnifiedRecord& record)
+{
+    Object plainUds;
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::PLAIN_TEXT);
+    plainUds.value_[UDMF::UNIFORM_DATA_TYPE] = utdId;
+    plainUds.value_[UDMF::CONTENT] = text_;
+    record.AddEntry(utdId, std::make_shared<Object>(plainUds));
+}
+
+void ConvertUtilsTest::AddFileUriUdsEntry(UDMF::UnifiedRecord& record)
+{
+    Object fileUriobject;
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::FILE_URI);
+    fileUriobject.value_[UDMF::UNIFORM_DATA_TYPE] = utdId;
+    fileUriobject.value_[UDMF::FILE_URI_PARAM] = uri_;
+    fileUriobject.value_[UDMF::FILE_TYPE] = "";
+    record.AddEntry(utdId, std::make_shared<Object>(fileUriobject));
+}
+
+void ConvertUtilsTest::AddHtmlUdsEntry(UDMF::UnifiedRecord& record)
+{
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HTML);
+    Object htmlobject;
+    htmlobject.value_[UDMF::UNIFORM_DATA_TYPE] = utdId;
+    htmlobject.value_[UDMF::HTML_CONTENT] = html_;
+    record.AddEntry(utdId, std::make_shared<Object>(htmlobject));
+}
+
+void ConvertUtilsTest::AddLinkUdsEntry(UDMF::UnifiedRecord& record)
+{
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HYPERLINK);
+    Object linkObject;
+    linkObject.value_[UDMF::UNIFORM_DATA_TYPE] = utdId;
+    linkObject.value_[UDMF::URL] = link_;
+    record.AddEntry(utdId, std::make_shared<Object>(linkObject));
+}
+
+void ConvertUtilsTest::AddCustomEntry(UDMF::UnifiedRecord& record)
+{
+    record.AddEntry(appUtdId1_, rawData1_);
+}
+
+void ConvertUtilsTest::AddCustomEntries(UDMF::UnifiedRecord& record)
+{
+    record.AddEntry(appUtdId1_, rawData1_);
+    record.AddEntry(appUtdId2_, rawData2_);
+}
+
+void ConvertUtilsTest::AddPixelMapUdsEntry(UDMF::UnifiedRecord& record)
+{
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::SYSTEM_DEFINED_PIXEL_MAP);
+    Object object;
+    object.value_[UDMF::UNIFORM_DATA_TYPE] = utdId;
+    uint32_t color[100] = { 3, 7, 9, 9, 7, 6 };
+    InitializationOptions opts = { { 5, 7 }, PixelFormat::ARGB_8888, PixelFormat::ARGB_8888 };
+    std::unique_ptr<PixelMap> pixelMap = PixelMap::Create(color, sizeof(color) / sizeof(color[0]), opts);
+    std::shared_ptr<PixelMap> pixelMapIn = move(pixelMap);
+    object.value_[UDMF::PIXEL_MAP] = pixelMapIn;
+    record.AddEntry(utdId, std::make_shared<Object>(object));
+}
+
+void ConvertUtilsTest::InitDataWithPlainEntry(UDMF::UnifiedData& data)
+{
+    std::shared_ptr<UDMF::UnifiedRecord> record = std::make_shared<UDMF::UnifiedRecord>();
+    AddPlainUdsEntry(*record);
+    data.AddRecord(record);
+    auto size = data.GetRecords().size();
+    ASSERT_EQ(1, size);
+    auto entriesSize = data.GetRecordAt(0)->GetEntries()->size();
+    ASSERT_EQ(1, entriesSize);
+}
+
+void ConvertUtilsTest::InitDataWithHtmlEntry(UDMF::UnifiedData& data)
+{
+    std::shared_ptr<UDMF::UnifiedRecord> record = std::make_shared<UDMF::UnifiedRecord>();
+    AddHtmlUdsEntry(*record);
+    data.AddRecord(record);
+    auto size = data.GetRecords().size();
+    ASSERT_EQ(1, size);
+    auto entriesSize = data.GetRecordAt(0)->GetEntries()->size();
+    ASSERT_EQ(1, entriesSize);
+}
+
+void ConvertUtilsTest::InitDataWithFileUriEntry(UDMF::UnifiedData& data)
+{
+    std::shared_ptr<UDMF::UnifiedRecord> record = std::make_shared<UDMF::UnifiedRecord>();
+    AddFileUriUdsEntry(*record);
+    data.AddRecord(record);
+    auto size = data.GetRecords().size();
+    ASSERT_EQ(1, size);
+    auto entriesSize = data.GetRecordAt(0)->GetEntries()->size();
+    ASSERT_EQ(1, entriesSize);
+}
+
+void ConvertUtilsTest::InitDataWithPixelMapEntry(UDMF::UnifiedData& data)
+{
+    std::shared_ptr<UDMF::UnifiedRecord> record = std::make_shared<UDMF::UnifiedRecord>();
+    AddPixelMapUdsEntry(*record);
+    data.AddRecord(record);
+    auto size = data.GetRecords().size();
+    ASSERT_EQ(1, size);
+    auto entriesSize = data.GetRecordAt(0)->GetEntries()->size();
+    ASSERT_EQ(1, entriesSize);
+}
+
+void ConvertUtilsTest::InitDataWitCustomEntry(UDMF::UnifiedData& data)
+{
+    std::shared_ptr<UDMF::UnifiedRecord> record = std::make_shared<UDMF::UnifiedRecord>();
+    AddCustomEntry(*record);
+    data.AddRecord(record);
+    auto size = data.GetRecords().size();
+    ASSERT_EQ(1, size);
+    auto entriesSize = data.GetRecordAt(0)->GetEntries()->size();
+    ASSERT_EQ(1, entriesSize);
+}
+
+void ConvertUtilsTest::InitDataWitSameCustomEntry(UDMF::UnifiedData& data)
+{
+    std::shared_ptr<UDMF::UnifiedRecord> record = std::make_shared<UDMF::UnifiedRecord>();
+    AddCustomEntry(*record);
+    record->AddEntry(appUtdId1_, rawData2_);
+    data.AddRecord(record);
+    auto size = data.GetRecords().size();
+    ASSERT_EQ(1, size);
+    auto entriesSize = data.GetRecordAt(0)->GetEntries()->size();
+    ASSERT_EQ(1, entriesSize);
+}
+
+void ConvertUtilsTest::InitDataWithEntries(UDMF::UnifiedData& data)
+{
+    std::shared_ptr<UDMF::UnifiedRecord> record = std::make_shared<UDMF::UnifiedRecord>();
+    AddPlainUdsEntry(*record);
+    AddHtmlUdsEntry(*record);
+    AddFileUriUdsEntry(*record);
+    AddLinkUdsEntry(*record);
+    AddCustomEntries(*record);
+    auto entriesSize = record->GetEntries()->size();
+    ASSERT_EQ(6, entriesSize);
+    data.AddRecord(record);
+    auto size = data.GetRecords().size();
+    ASSERT_EQ(1, size);
+
+}
+
+void ConvertUtilsTest::CheckEntries(const std::vector<std::shared_ptr<PasteDataEntry>>& entries)
+{
+    for (auto const& entry : entries) {
+        if (entry->GetUtdId() == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::PLAIN_TEXT)) {
+            CheckPlainUds(entry);
+        } else if (entry->GetUtdId() == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::FILE_URI)) {
+            CheckFileUriUds(entry);
+        } else if (entry->GetUtdId() == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::SYSTEM_DEFINED_PIXEL_MAP)) {
+            CheckPixelMapUds(entry);
+        } else if (entry->GetUtdId() == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HYPERLINK)) {
+            CheckLinkUds(entry);
+        } else if (entry->GetUtdId() == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HTML)) {
+            CheckHtmlUds(entry);
+        } else {
+            CheckCustomEntry(entry);
+        }
+    }
+}
+
+void ConvertUtilsTest::CheckPlainUds(const std::shared_ptr<PasteDataEntry> entry)
+{
+    ASSERT_NE(entry, nullptr);
+    ASSERT_EQ(MIMETYPE_TEXT_PLAIN, entry->GetMimeType());
+    auto decodeValue = entry->GetValue();
+    auto object = std::get_if<std::shared_ptr<Object>>(&decodeValue);
+    ASSERT_NE(object, nullptr);
+    auto objectValue = (*object)->value_;
+    auto typeValue = std::get_if<std::string>(&objectValue[UDMF::UNIFORM_DATA_TYPE]);
+    ASSERT_NE(typeValue, nullptr);
+    ASSERT_EQ(*typeValue, UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::PLAIN_TEXT));
+    auto value = std::get_if<std::string>(&objectValue[UDMF::CONTENT]);
+    ASSERT_NE(value, nullptr);
+    ASSERT_EQ(*value, text_);
+}
+
+void ConvertUtilsTest::CheckFileUriUds(const std::shared_ptr<PasteDataEntry> entry)
+{
+    ASSERT_NE(entry, nullptr);
+    ASSERT_EQ(MIMETYPE_TEXT_URI, entry->GetMimeType());
+    auto decodeValue = entry->GetValue();
+    auto object = std::get_if<std::shared_ptr<Object>>(&decodeValue);
+    ASSERT_NE(object, nullptr);
+    auto objectValue = (*object)->value_;
+    auto typeValue = std::get_if<std::string>(&objectValue[UDMF::UNIFORM_DATA_TYPE]);
+    ASSERT_NE(typeValue, nullptr);
+    ASSERT_EQ(*typeValue, UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::FILE_URI));
+    auto value = std::get_if<std::string>(&objectValue[UDMF::FILE_URI_PARAM]);
+    ASSERT_NE(value, nullptr);
+    ASSERT_EQ(*value, uri_);
+}
+
+void ConvertUtilsTest::CheckHtmlUds(const std::shared_ptr<PasteDataEntry> entry)
+{
+    ASSERT_NE(entry, nullptr);
+    ASSERT_EQ(MIMETYPE_TEXT_HTML, entry->GetMimeType());
+    auto decodeValue = entry->GetValue();
+    auto object = std::get_if<std::shared_ptr<Object>>(&decodeValue);
+    ASSERT_NE(object, nullptr);
+    auto objectValue = (*object)->value_;
+    auto typeValue = std::get_if<std::string>(&objectValue[UDMF::UNIFORM_DATA_TYPE]);
+    ASSERT_NE(typeValue, nullptr);
+    ASSERT_EQ(*typeValue, UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HTML));
+    auto value = std::get_if<std::string>(&objectValue[UDMF::HTML_CONTENT]);
+    ASSERT_NE(value, nullptr);
+    ASSERT_EQ(*value, html_);
+}
+
+void ConvertUtilsTest::CheckPixelMapUds(const std::shared_ptr<PasteDataEntry> entry)
+{
+    ASSERT_NE(entry, nullptr);
+    ASSERT_EQ(MIMETYPE_PIXELMAP, entry->GetMimeType());
+    auto decodeValue = entry->GetValue();
+    auto object = std::get_if<std::shared_ptr<Object>>(&decodeValue);
+    ASSERT_NE(object, nullptr);
+    auto objectValue = (*object)->value_;
+    auto typeValue = std::get_if<std::string>(&objectValue[UDMF::UNIFORM_DATA_TYPE]);
+    ASSERT_NE(typeValue, nullptr);
+    ASSERT_EQ(*typeValue, UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::SYSTEM_DEFINED_PIXEL_MAP));
+    auto value = std::get_if<std::shared_ptr<PixelMap>>(&objectValue[UDMF::PIXEL_MAP]);
+    ASSERT_NE(value, nullptr);
+    ImageInfo imageInfo = {};
+    (*value)->GetImageInfo(imageInfo);
+    ASSERT_TRUE(imageInfo.size.height == 7);
+    ASSERT_TRUE(imageInfo.size.width == 5);
+    ASSERT_TRUE(imageInfo.pixelFormat == PixelFormat::ARGB_8888);
+}
+
+void ConvertUtilsTest::CheckLinkUds(const std::shared_ptr<PasteDataEntry> entry)
+{
+    ASSERT_NE(entry, nullptr);
+    ASSERT_EQ(MIMETYPE_TEXT_PLAIN, entry->GetMimeType());
+    auto decodeValue = entry->GetValue();
+    auto object = std::get_if<std::shared_ptr<Object>>(&decodeValue);
+    ASSERT_NE(object, nullptr);
+    auto objectValue = (*object)->value_;
+    auto typeValue = std::get_if<std::string>(&objectValue[UDMF::UNIFORM_DATA_TYPE]);
+    ASSERT_NE(typeValue, nullptr);
+    ASSERT_EQ(*typeValue, UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HYPERLINK));
+    auto value = std::get_if<std::string>(&objectValue[UDMF::URL]);
+    ASSERT_NE(value, nullptr);
+    ASSERT_EQ(*value, link_);
+}
+
+void ConvertUtilsTest::CheckCustomEntry(const std::shared_ptr<PasteDataEntry> entry)
+{
+    ASSERT_NE(entry, nullptr);
+    ASSERT_EQ(entry->GetUtdId(), entry->GetMimeType());
+    auto decodeValue = entry->GetValue();
+    auto object = std::get_if<std::vector<uint8_t>>(&decodeValue);
+    ASSERT_NE(object, nullptr);
+    if (entry->GetUtdId() == appUtdId1_) {
+        ASSERT_EQ(*object, rawData1_);
+    } else {
+        ASSERT_EQ(*object, rawData2_);
+    }
+}
+
+/**
+* @tc.name: PlainEntryTest001
+* @tc.desc:
+* @tc.type: FUNC
+* @tc.require:
+* @tc.author:tarowang
+*/
+HWTEST_F(ConvertUtilsTest, PlainEntryTest001, TestSize.Level0)
+{
+    UDMF::UnifiedData data;
+    InitDataWithPlainEntry(data);
+    auto entriesSize = data.GetRecordAt(0)->GetEntries()->size();
+    auto pasteData = ConvertUtils::Convert(data);
+    auto decodePasteData = TlvData(pasteData);
+    ASSERT_EQ(1, decodePasteData.GetRecordCount());
+    auto record = decodePasteData.GetRecordAt(0);
+    auto type = record->GetMimeType();
+    ASSERT_EQ(type, MIMETYPE_TEXT_PLAIN);
+    auto udType = record->GetUDType();
+    ASSERT_EQ(udType, UDMF::UDType::PLAIN_TEXT);
+    auto plain = record->GetPlainText();
+    ASSERT_EQ(*plain, text_);
+    auto entries = record->GetEntries();
+    ASSERT_EQ(entries.size(), entriesSize);
+    CheckEntries(entries);
+}
+
+/**
+* @tc.name: HtmlEntryTest001
+* @tc.desc:
+* @tc.type: FUNC
+* @tc.require:
+* @tc.author:tarowang
+*/
+HWTEST_F(ConvertUtilsTest, HtmlEntryTest001, TestSize.Level0)
+{
+    UDMF::UnifiedData data;
+    InitDataWithHtmlEntry(data);
+    auto entriesSize = data.GetRecordAt(0)->GetEntries()->size();
+    auto pasteData = ConvertUtils::Convert(data);
+    auto decodePasteData = TlvData(pasteData);
+    ASSERT_EQ(1, decodePasteData.GetRecordCount());
+    auto record = decodePasteData.GetRecordAt(0);
+    auto type = record->GetMimeType();
+    ASSERT_EQ(type, MIMETYPE_TEXT_HTML);
+    auto udType = record->GetUDType();
+    ASSERT_EQ(udType, UDMF::UDType::HTML);
+    auto plain = record->GetHtmlText();
+    ASSERT_EQ(*plain, html_);
+    auto entries = record->GetEntries();
+    ASSERT_EQ(entries.size(), entriesSize);
+    CheckEntries(entries);
+}
+
+/**
+* @tc.name: PixelMapEntryTest001
+* @tc.desc:
+* @tc.type: FUNC
+* @tc.require:
+* @tc.author:tarowang
+*/
+HWTEST_F(ConvertUtilsTest, PixelMapEntryTest001, TestSize.Level0)
+{
+    // UDMF::UnifiedData data;
+    // InitDataWithPixelMapEntry(data);
+    // auto entriesSize = data.GetRecordAt(0)->GetEntries()->size();
+    // auto pasteData = ConvertUtils::Convert(data);
+    // auto decodePasteData = TlvData(pasteData);
+    // ASSERT_EQ(1, decodePasteData.GetRecordCount());
+    // auto record = decodePasteData.GetRecordAt(0);
+    // auto type = record->GetMimeType();
+    // ASSERT_EQ(type, MIMETYPE_PIXELMAP);
+    // auto udType = record->GetUDType();
+    // ASSERT_EQ(udType, UDMF::UDType::SYSTEM_DEFINED_PIXEL_MAP);
+    // auto pixelMap = record->GetPixelMap();
+    // ASSERT_NE(pixelMap, nullptr);
+    // ImageInfo imageInfo = {};
+    // pixelMap->GetImageInfo(imageInfo);
+    // ASSERT_TRUE(imageInfo.size.height == 7);
+    // ASSERT_TRUE(imageInfo.size.width == 5);
+    // ASSERT_TRUE(imageInfo.pixelFormat == PixelFormat::ARGB_8888);
+    // auto entries = record->GetEntries();
+    // ASSERT_EQ(entries.size(), entriesSize);
+    // CheckEntries(entries);
+}
+
+/**
+* @tc.name: EntriesTest001
+* @tc.desc:
+* @tc.type: FUNC
+* @tc.require:
+* @tc.author:tarowang
+*/
+HWTEST_F(ConvertUtilsTest, EntriesTest001, TestSize.Level0)
+{
+    UDMF::UnifiedData data;
+    InitDataWithEntries(data);
+    auto entriesSize = data.GetRecordAt(0)->GetEntries()->size();
+    auto pasteData = ConvertUtils::Convert(data);
+    auto decodePasteData = TlvData(pasteData);
+    ASSERT_EQ(1, decodePasteData.GetRecordCount());
+    auto record = decodePasteData.GetRecordAt(0);
+    auto type = record->GetMimeType();
+    ASSERT_EQ(type, MIMETYPE_TEXT_PLAIN);
+    auto udType = record->GetUDType();
+    ASSERT_EQ(udType, UDMF::UDType::PLAIN_TEXT);
+    auto plain = record->GetPlainText();
+    ASSERT_NE(plain, nullptr);
+    ASSERT_EQ(*plain, text_);
+
+    auto entries = record->GetEntries();
+    ASSERT_EQ(entries.size(), entriesSize);
+    CheckEntries(entries);
+}
+
+/**
+* @tc.name: SameTypeEntryTest001
+* @tc.desc:
+* @tc.type: FUNC
+* @tc.require:
+* @tc.author:tarowang
+*/
+HWTEST_F(ConvertUtilsTest, SameTypeEntryTest001, TestSize.Level0)
+{
+    UDMF::UnifiedData data;
+    InitDataWitSameCustomEntry(data);
+    auto pasteData = ConvertUtils::Convert(data);
+    auto decodePasteData = TlvData(pasteData);
+    ASSERT_EQ(1, decodePasteData.GetRecordCount());
+    auto record = decodePasteData.GetRecordAt(0);
+    auto type = record->GetMimeType();
+    ASSERT_EQ(type, appUtdId1_);
+    auto udType = record->GetUDType();
+    ASSERT_EQ(udType, UDMF::UDType::APPLICATION_DEFINED_RECORD);
+    auto customData = record->GetCustomData();
+    ASSERT_NE(customData, nullptr);
+    auto rawData = customData->GetItemData();
+    ASSERT_EQ(rawData.size(), 1);
+    ASSERT_EQ(rawData[appUtdId1_], rawData2_);
+}
+} // namespace OHOS::MiscServices
\ No newline at end of file
diff --git a/framework/test/src/paste_data_entry_test.cpp b/framework/test/src/paste_data_entry_test.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..6c8e5d18e6e71e171abcbbd3f48701f3ad53488d
--- /dev/null
+++ b/framework/test/src/paste_data_entry_test.cpp
@@ -0,0 +1,254 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "convert_utils.h"
+#include <gtest/gtest.h>
+#include "unified_meta.h"
+
+namespace OHOS::MiscServices {
+using namespace testing::ext;
+using namespace testing;
+using namespace OHOS::Media;
+class PasteDataEntryTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+
+protected:
+    PasteDataEntry InitPlaintTextEntry();
+    PasteDataEntry InitPixelMapEntry();
+    PasteDataEntry InitUriEntry();
+    PasteDataEntry InitWantEntry();
+    PasteDataEntry InitHtmlEntry();
+    void CheckPlainUds(std::shared_ptr<PasteDataEntry> entry);
+    void CheckPixelMapUds(std::shared_ptr<PasteDataEntry> entry);
+    std::string text_ = "test_string";
+    std::string uri_ = "file://test_uri";
+    std::string html_ = "<div class='disable'>helloWorld</div>";
+    int32_t width_ = 5;
+    int32_t height_ = 7;
+};
+
+void PasteDataEntryTest::SetUpTestCase(void) {}
+
+void PasteDataEntryTest::TearDownTestCase(void) {}
+
+void PasteDataEntryTest::SetUp(void) {}
+
+void PasteDataEntryTest::TearDown(void) {}
+
+PasteDataEntry PasteDataEntryTest::InitPlaintTextEntry()
+{
+    auto udsObject = std::make_shared<Object>();
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::PLAIN_TEXT);
+    udsObject->value_[UDMF::UNIFORM_DATA_TYPE] = utdId;
+    udsObject->value_[UDMF::CONTENT] = text_;
+    return {utdId, udsObject};
+}
+
+PasteDataEntry PasteDataEntryTest::InitUriEntry()
+{
+    auto udsObject = std::make_shared<Object>();
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::FILE_URI);
+    udsObject->value_[UDMF::UNIFORM_DATA_TYPE] = utdId;
+    udsObject->value_[UDMF::FILE_URI_PARAM] = uri_;
+    udsObject->value_[UDMF::FILE_TYPE] = "";
+    return {utdId, udsObject};
+}
+
+PasteDataEntry PasteDataEntryTest::InitWantEntry()
+{
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::OPENHARMONY_WANT);
+    using namespace OHOS::AAFwk;
+    std::shared_ptr<Want> want = std::make_shared<Want>();
+    std::string idKey = "id";
+    int32_t idValue = 123;
+    std::string deviceKey = "deviceId_key";
+    want->SetParam(idKey, idValue);
+    return {utdId, want};
+}
+
+PasteDataEntry PasteDataEntryTest::InitHtmlEntry()
+{
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HTML);
+    auto udsObject = std::make_shared<Object>();
+    udsObject->value_[UDMF::UNIFORM_DATA_TYPE] = utdId;
+    udsObject->value_[UDMF::HTML_CONTENT] = html_;
+    return {utdId, udsObject};
+}
+
+PasteDataEntry PasteDataEntryTest::InitPixelMapEntry()
+{
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::SYSTEM_DEFINED_PIXEL_MAP);
+    auto udsObject = std::make_shared<Object>();
+    udsObject->value_[UDMF::UNIFORM_DATA_TYPE] = utdId;
+    uint32_t color[100] = { 3, 7, 9, 9, 7, 6 };
+    InitializationOptions opts = { { 5, 7 }, PixelFormat::ARGB_8888, PixelFormat::ARGB_8888 };
+    std::unique_ptr<PixelMap> pixelMap = PixelMap::Create(color, sizeof(color) / sizeof(color[0]), opts);
+    std::shared_ptr<PixelMap> pixelMapIn = move(pixelMap);
+    udsObject->value_[UDMF::PIXEL_MAP] = pixelMapIn;
+    return {utdId, udsObject};
+}
+
+
+void PasteDataEntryTest::CheckPlainUds(const std::shared_ptr<PasteDataEntry> entry)
+{
+    ASSERT_NE(entry, nullptr);
+    ASSERT_EQ(MIMETYPE_TEXT_PLAIN, entry->GetMimeType());
+    auto decodeValue = entry->GetValue();
+    auto object = std::get_if<std::shared_ptr<Object>>(&decodeValue);
+    ASSERT_NE(object, nullptr);
+    auto objectValue = (*object)->value_;
+    auto typeValue = std::get_if<std::string>(&objectValue[UDMF::UNIFORM_DATA_TYPE]);
+    ASSERT_NE(typeValue, nullptr);
+    ASSERT_EQ(*typeValue, UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::PLAIN_TEXT));
+    auto value = std::get_if<std::string>(&objectValue[UDMF::CONTENT]);
+    ASSERT_NE(value, nullptr);
+    ASSERT_EQ(*value, text_);
+}
+
+void PasteDataEntryTest::CheckPixelMapUds(const std::shared_ptr<PasteDataEntry> entry)
+{
+    ASSERT_NE(entry, nullptr);
+    ASSERT_EQ(MIMETYPE_PIXELMAP, entry->GetMimeType());
+    auto decodeValue = entry->GetValue();
+    auto object = std::get_if<std::shared_ptr<Object>>(&decodeValue);
+    ASSERT_NE(object, nullptr);
+    auto objectValue = (*object)->value_;
+    auto typeValue = std::get_if<std::string>(&objectValue[UDMF::UNIFORM_DATA_TYPE]);
+    ASSERT_NE(typeValue, nullptr);
+    ASSERT_EQ(*typeValue, UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::SYSTEM_DEFINED_PIXEL_MAP));
+    auto value = std::get_if<std::shared_ptr<PixelMap>>(&objectValue[UDMF::PIXEL_MAP]);
+    ASSERT_NE(value, nullptr);
+    ImageInfo imageInfo = {};
+    (*value)->GetImageInfo(imageInfo);
+    ASSERT_TRUE(imageInfo.size.height == 7);
+    ASSERT_TRUE(imageInfo.size.width == 5);
+    ASSERT_TRUE(imageInfo.pixelFormat == PixelFormat::ARGB_8888);
+}
+
+/**
+* @tc.name: Convert001
+* @tc.desc: convert to palinText;
+* @tc.type: FUNC
+* @tc.require:entries
+* @tc.author: tarowang
+*/
+HWTEST_F(PasteDataEntryTest, Convert001, TestSize.Level0)
+{
+    auto entry = InitPlaintTextEntry();
+    auto str = entry.ConvertToPlianText();
+    ASSERT_NE(nullptr, str);
+    EXPECT_EQ(text_, *str);
+
+    entry = InitHtmlEntry();
+    auto html = entry.ConvertToHtml();
+    ASSERT_NE(nullptr, html);
+    EXPECT_EQ(html_, *html);
+
+    entry = InitUriEntry();
+    auto uri = entry.ConvertToUri();
+    ASSERT_NE(nullptr, uri);
+    EXPECT_EQ(uri_, uri->ToString());
+
+    entry = InitWantEntry();
+    auto want = entry.ConvertToWant();
+    ASSERT_NE(nullptr, want);
+    int32_t idValue1 = want->GetIntParam("id", 0);
+    ASSERT_EQ(idValue1, 123);
+
+    entry = InitPixelMapEntry();
+    auto pixelMap = entry.ConvertToPixelMap();
+    ASSERT_NE(nullptr, pixelMap);
+    ImageInfo imageInfo = {};
+    pixelMap->GetImageInfo(imageInfo);
+    ASSERT_TRUE(imageInfo.size.height == height_);
+    ASSERT_TRUE(imageInfo.size.width == width_);
+    ASSERT_TRUE(imageInfo.pixelFormat == PixelFormat::ARGB_8888);
+}
+
+/**
+* @tc.name: EntriesTest001
+* @tc.desc:
+* @tc.type: FUNC
+* @tc.require:
+* @tc.author:tarowang
+*/
+HWTEST_F(PasteDataEntryTest, EntryTlvTest001, TestSize.Level0)
+{
+    PasteDataEntry entry;
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::PLAIN_TEXT);
+    entry.SetUtdId(utdId);
+    entry.SetMimeType(MIMETYPE_TEXT_PLAIN);
+    entry.SetValue(text_);
+
+    std::vector<std::uint8_t> buffer;
+    entry.Marshalling(buffer);
+    PasteDataEntry decodePasteEntry;
+    auto ret = decodePasteEntry.Unmarshalling(buffer);
+
+    ASSERT_EQ(ret, true);
+    ASSERT_EQ(decodePasteEntry.GetUtdId(), utdId);
+    ASSERT_EQ(decodePasteEntry.GetMimeType(), MIMETYPE_TEXT_PLAIN);
+    auto value = decodePasteEntry.GetValue();
+    auto str = std::get_if<std::string>(&value);
+    ASSERT_NE(str, nullptr);
+    ASSERT_EQ(text_, *str);
+}
+
+/**
+* @tc.name: EntryTlvTest002
+* @tc.desc:
+* @tc.type: FUNC
+* @tc.require:
+* @tc.author:tarowang
+*/
+HWTEST_F(PasteDataEntryTest, EntryTlvTest002, TestSize.Level0)
+{
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::PLAIN_TEXT);
+    auto entry = InitPlaintTextEntry();
+    std::vector<std::uint8_t> buffer;
+    entry.Marshalling(buffer);
+    PasteDataEntry decodePasteEntry;
+    auto ret = decodePasteEntry.Unmarshalling(buffer);
+    ASSERT_EQ(ret, true);
+    ASSERT_EQ(decodePasteEntry.GetUtdId(), utdId);
+    ASSERT_EQ(decodePasteEntry.GetMimeType(), MIMETYPE_TEXT_PLAIN);
+    CheckPlainUds(std::make_shared<PasteDataEntry>(decodePasteEntry));
+}
+
+/**
+* @tc.name: EntryTlvTest003
+* @tc.desc:
+* @tc.type: EntryTlvTest003 with pixelMap
+* @tc.require:
+* @tc.author:tarowang
+*/
+HWTEST_F(PasteDataEntryTest, EntryTlvTest003, TestSize.Level0)
+{
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::SYSTEM_DEFINED_PIXEL_MAP);
+    auto entry = InitPixelMapEntry();
+    std::vector<std::uint8_t> buffer;
+    entry.Marshalling(buffer);
+    PasteDataEntry decodePasteEntry;
+    auto ret = decodePasteEntry.Unmarshalling(buffer);
+    ASSERT_EQ(ret, true);
+    ASSERT_EQ(decodePasteEntry.GetUtdId(), utdId);
+    ASSERT_EQ(decodePasteEntry.GetMimeType(), MIMETYPE_PIXELMAP);
+    CheckPixelMapUds(std::make_shared<PasteDataEntry>(decodePasteEntry));
+}
+} // namespace OHOS::MiscServices
\ No newline at end of file
diff --git a/framework/test/src/paste_data_record_test.cpp b/framework/test/src/paste_data_record_test.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..f6c89bf5b80bbc30904ce33be2eab790b3dc8e43
--- /dev/null
+++ b/framework/test/src/paste_data_record_test.cpp
@@ -0,0 +1,306 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "paste_data_record.h"
+
+#include <gtest/gtest.h>
+
+#include "tlv_object.h"
+#include "unified_meta.h"
+
+namespace OHOS::MiscServices {
+using namespace testing::ext;
+using namespace testing;
+using namespace OHOS::Media;
+class PasteDataRecordTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+
+protected:
+    Details details_;
+    std::vector<uint8_t> rawData_;
+    std::string text_ = "test";
+    std::string extraText_ = "extr";
+    std::string uri_ = "file://123.txt";
+    std::string html_ = "<div class='disable'>helloWorld</div>";
+    std::string link_ = "http://abc.com";
+    int32_t width_ = 5;
+    int32_t height_ = 7;
+
+    void CheckEntries(const std::vector<std::shared_ptr<PasteDataEntry>>& entries);
+    void CheckPlainUds(const std::shared_ptr<PasteDataEntry> entry);
+    void CheckFileUriUds(const std::shared_ptr<PasteDataEntry> entry);
+    void CheckPixelMapUds(const std::shared_ptr<PasteDataEntry> entry);
+    void CheckHtmlUds(const std::shared_ptr<PasteDataEntry> entry);
+    void CheckLinkUds(const std::shared_ptr<PasteDataEntry> entry);
+
+    void AddPlainUdsEntry(PasteDataRecord& record);
+    void AddFileUriUdsEntry(PasteDataRecord& record);
+    void AddHtmlUdsEntry(PasteDataRecord& record);
+    void AddPixelMapUdsEntry(PasteDataRecord& record);
+    void AddLinkUdsEntry(PasteDataRecord& record);
+};
+
+void PasteDataRecordTest::SetUpTestCase(void) {}
+
+void PasteDataRecordTest::TearDownTestCase(void) {}
+
+void PasteDataRecordTest::SetUp(void)
+{
+    rawData_ = { 1, 2, 3, 4, 5, 6, 7, 8 };
+    details_.insert({ "keyString", "string_test" });
+    details_.insert({ "keyInt32", 1 });
+    details_.insert({ "keyBool", true });
+    details_.insert({ "KeyU8Array", rawData_ });
+    details_.insert({ "KeyDouble", 1.234 });
+}
+
+void PasteDataRecordTest::TearDown(void) {}
+
+void PasteDataRecordTest::AddPlainUdsEntry(PasteDataRecord& record)
+{
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::PLAIN_TEXT);
+    auto object = std::make_shared<Object>();
+    object->value_[UDMF::UNIFORM_DATA_TYPE] = utdId;
+    object->value_[UDMF::CONTENT] = text_;
+    record.AddEntry(utdId, std::make_shared<PasteDataEntry>(utdId, object));
+}
+
+void PasteDataRecordTest::AddFileUriUdsEntry(PasteDataRecord& record)
+{
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::FILE_URI);
+    auto object = std::make_shared<Object>();
+    object->value_[UDMF::UNIFORM_DATA_TYPE] = utdId;
+    object->value_[UDMF::FILE_URI_PARAM] = uri_;
+    object->value_[UDMF::FILE_TYPE] = "";
+    record.AddEntry(utdId, std::make_shared<PasteDataEntry>(utdId, object));
+}
+
+void PasteDataRecordTest::AddHtmlUdsEntry(PasteDataRecord& record)
+{
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HTML);
+    auto object = std::make_shared<Object>();
+    object->value_[UDMF::UNIFORM_DATA_TYPE] = utdId;
+    object->value_[UDMF::HTML_CONTENT] = html_;
+    record.AddEntry(utdId, std::make_shared<PasteDataEntry>(utdId, object));
+}
+
+void PasteDataRecordTest::AddLinkUdsEntry(PasteDataRecord& record)
+{
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HYPERLINK);
+    auto object = std::make_shared<Object>();
+    object->value_[UDMF::UNIFORM_DATA_TYPE] = utdId;
+    object->value_[UDMF::URL] = link_;
+    record.AddEntry(utdId, std::make_shared<PasteDataEntry>(utdId, object));
+}
+
+void PasteDataRecordTest::AddPixelMapUdsEntry(PasteDataRecord& record)
+{
+    auto utdId = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::SYSTEM_DEFINED_PIXEL_MAP);
+    auto object = std::make_shared<Object>();
+    object->value_[UDMF::UNIFORM_DATA_TYPE] = utdId;
+    uint32_t color[100] = { 3, 7, 9, 9, 7, 6 };
+    InitializationOptions opts = { { width_, height_ }, PixelFormat::ARGB_8888, PixelFormat::ARGB_8888 };
+    std::unique_ptr<PixelMap> pixelMap = PixelMap::Create(color, sizeof(color) / sizeof(color[0]), opts);
+    std::shared_ptr<PixelMap> pixelMapIn = move(pixelMap);
+    object->value_[UDMF::PIXEL_MAP] = pixelMapIn;
+    record.AddEntry(utdId, std::make_shared<PasteDataEntry>(utdId, object));
+}
+
+void PasteDataRecordTest::CheckEntries(const std::vector<std::shared_ptr<PasteDataEntry>>& entries)
+{
+    for (auto const& entry : entries) {
+        if (entry->GetUtdId() == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::PLAIN_TEXT)) {
+            CheckPlainUds(entry);
+        }
+        if (entry->GetUtdId() == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::FILE_URI)) {
+            CheckFileUriUds(entry);
+        }
+        if (entry->GetUtdId() == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::SYSTEM_DEFINED_PIXEL_MAP)) {
+            CheckPixelMapUds(entry);
+        }
+        if (entry->GetUtdId() == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HYPERLINK)) {
+            CheckLinkUds(entry);
+        }
+        if (entry->GetUtdId() == UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HTML)) {
+            CheckHtmlUds(entry);
+        }
+    }
+}
+
+void PasteDataRecordTest::CheckPlainUds(const std::shared_ptr<PasteDataEntry> entry)
+{
+    ASSERT_EQ(MIMETYPE_TEXT_PLAIN, entry->GetMimeType());
+    auto decodeValue = entry->GetValue();
+    auto object = std::get_if<std::shared_ptr<Object>>(&decodeValue);
+    ASSERT_NE(object, nullptr);
+    auto objectValue = (*object)->value_;
+    auto typeValue = std::get_if<std::string>(&objectValue[UDMF::UNIFORM_DATA_TYPE]);
+    ASSERT_NE(typeValue, nullptr);
+    ASSERT_EQ(*typeValue, UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::PLAIN_TEXT));
+    auto value = std::get_if<std::string>(&objectValue[UDMF::CONTENT]);
+    ASSERT_NE(value, nullptr);
+    ASSERT_EQ(*value, text_);
+}
+
+void PasteDataRecordTest::CheckFileUriUds(const std::shared_ptr<PasteDataEntry> entry)
+{
+    ASSERT_EQ(MIMETYPE_TEXT_URI, entry->GetMimeType());
+    auto decodeValue = entry->GetValue();
+    auto object = std::get_if<std::shared_ptr<Object>>(&decodeValue);
+    ASSERT_NE(object, nullptr);
+    auto objectValue = (*object)->value_;
+    auto typeValue = std::get_if<std::string>(&objectValue[UDMF::UNIFORM_DATA_TYPE]);
+    ASSERT_NE(typeValue, nullptr);
+    ASSERT_EQ(*typeValue, UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::FILE_URI));
+    auto value = std::get_if<std::string>(&objectValue[UDMF::FILE_URI_PARAM]);
+    ASSERT_NE(value, nullptr);
+    ASSERT_EQ(*value, uri_);
+}
+
+void PasteDataRecordTest::CheckHtmlUds(const std::shared_ptr<PasteDataEntry> entry)
+{
+    ASSERT_EQ(MIMETYPE_TEXT_HTML, entry->GetMimeType());
+    auto decodeValue = entry->GetValue();
+    auto object = std::get_if<std::shared_ptr<Object>>(&decodeValue);
+    ASSERT_NE(object, nullptr);
+    auto objectValue = (*object)->value_;
+    auto typeValue = std::get_if<std::string>(&objectValue[UDMF::UNIFORM_DATA_TYPE]);
+    ASSERT_NE(typeValue, nullptr);
+    ASSERT_EQ(*typeValue, UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HTML));
+    auto value = std::get_if<std::string>(&objectValue[UDMF::HTML_CONTENT]);
+    ASSERT_NE(value, nullptr);
+    ASSERT_EQ(*value, html_);
+}
+
+void PasteDataRecordTest::CheckPixelMapUds(const std::shared_ptr<PasteDataEntry> entry)
+{
+    ASSERT_EQ(MIMETYPE_PIXELMAP, entry->GetMimeType());
+    auto decodeValue = entry->GetValue();
+    auto object = std::get_if<std::shared_ptr<Object>>(&decodeValue);
+    ASSERT_NE(object, nullptr);
+    auto objectValue = (*object)->value_;
+    auto typeValue = std::get_if<std::string>(&objectValue[UDMF::UNIFORM_DATA_TYPE]);
+    ASSERT_NE(typeValue, nullptr);
+    ASSERT_EQ(*typeValue, UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::SYSTEM_DEFINED_PIXEL_MAP));
+    auto value = std::get_if<std::shared_ptr<PixelMap>>(&objectValue[UDMF::PIXEL_MAP]);
+    ASSERT_NE(value, nullptr);
+    ImageInfo imageInfo = {};
+    (*value)->GetImageInfo(imageInfo);
+    ASSERT_TRUE(imageInfo.size.height == height_);
+    ASSERT_TRUE(imageInfo.size.width == width_);
+    ASSERT_TRUE(imageInfo.pixelFormat == PixelFormat::ARGB_8888);
+}
+
+void PasteDataRecordTest::CheckLinkUds(const std::shared_ptr<PasteDataEntry> entry)
+{
+    ASSERT_EQ(MIMETYPE_TEXT_PLAIN, entry->GetMimeType());
+    auto decodeValue = entry->GetValue();
+    auto object = std::get_if<std::shared_ptr<Object>>(&decodeValue);
+    ASSERT_NE(object, nullptr);
+    auto objectValue = (*object)->value_;
+    auto typeValue = std::get_if<std::string>(&objectValue[UDMF::UNIFORM_DATA_TYPE]);
+    ASSERT_NE(typeValue, nullptr);
+    ASSERT_EQ(*typeValue, UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HYPERLINK));
+    auto value = std::get_if<std::string>(&objectValue[UDMF::URL]);
+    ASSERT_NE(value, nullptr);
+    ASSERT_EQ(*value, link_);
+}
+
+/**
+* @tc.name: GetValidTypesTest001
+* @tc.desc: GetValidTypesTest001;
+* @tc.type: FUNC
+* @tc.require:entries
+* @tc.author: tarowang
+*/
+HWTEST_F(PasteDataRecordTest, GetValidTypesTest001, TestSize.Level0)
+{
+    std::shared_ptr<PasteDataRecord> record = std::make_shared<PasteDataRecord>();
+    AddPlainUdsEntry(*record);
+    AddHtmlUdsEntry(*record);
+
+    std::vector<std::string> inputTypes;
+    inputTypes.emplace_back(UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::FILE_URI));
+    inputTypes.emplace_back(UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HTML));
+
+    auto validTypes = record->GetValidTypes(inputTypes);
+    ASSERT_EQ(validTypes.size(), 1);
+    ASSERT_EQ(validTypes[0], UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HTML));
+}
+
+/**
+* @tc.name: AddEntryTest001
+* @tc.desc: Add entry test
+* @tc.type: FUNC
+* @tc.require:entries
+* @tc.author: tarowang
+*/
+HWTEST_F(PasteDataRecordTest, AddEntryTest001, TestSize.Level0)
+{
+    std::shared_ptr<PasteDataRecord> record = std::make_shared<PasteDataRecord>();
+    AddPlainUdsEntry(*record);
+    AddHtmlUdsEntry(*record);
+}
+
+/**
+* @tc.name: GetEntries001
+* @tc.desc: convert to palinText;
+* @tc.type: FUNC
+* @tc.require:entries
+* @tc.author: tarowang
+*/
+HWTEST_F(PasteDataRecordTest, GetEntries001, TestSize.Level0)
+{
+    std::vector<std::string> inputTypes;
+    inputTypes.emplace_back(UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::FILE_URI));
+    inputTypes.emplace_back(UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HTML));
+    inputTypes.emplace_back(UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::FILE_URI));
+    inputTypes.emplace_back(UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HYPERLINK));
+    inputTypes.emplace_back(UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::SYSTEM_DEFINED_PIXEL_MAP));
+
+    std::shared_ptr<PasteDataRecord> record = std::make_shared<PasteDataRecord>();
+    AddPlainUdsEntry(*record);
+    auto types = record->GetValidTypes(inputTypes);
+    ASSERT_EQ(types.size(), 0);
+
+    AddHtmlUdsEntry(*record);
+    types = record->GetValidTypes(inputTypes);
+    auto it = std::find(types.begin(), types.end(), UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HTML));
+    ASSERT_NE(it, types.end());
+
+    AddFileUriUdsEntry(*record);
+    types = record->GetValidTypes(inputTypes);
+    it = std::find(types.begin(), types.end(), UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::FILE_URI));
+    ASSERT_NE(it, types.end());
+
+    AddLinkUdsEntry(*record);
+    types = record->GetValidTypes(inputTypes);
+    it = std::find(types.begin(), types.end(), UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HYPERLINK));
+    ASSERT_NE(it, types.end());
+
+    AddPixelMapUdsEntry(*record);
+    types = record->GetValidTypes(inputTypes);
+    it = std::find(types.begin(), types.end(), UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::SYSTEM_DEFINED_PIXEL_MAP));
+    ASSERT_NE(it, types.end());
+
+    auto entries = record->GetEntries();
+    CheckEntries(entries);
+}
+
+} // namespace OHOS::MiscServices
\ No newline at end of file
diff --git a/framework/test/src/pasteboard_client_udmf_delay_test.cpp b/framework/test/src/pasteboard_client_udmf_delay_test.cpp
index a8977eacafabfb8f9d55b7bb7fd07665fc3ff288..a535ab11feebecd4f19350838e6063f5ed874105 100755
--- a/framework/test/src/pasteboard_client_udmf_delay_test.cpp
+++ b/framework/test/src/pasteboard_client_udmf_delay_test.cpp
@@ -28,6 +28,7 @@
 #include "system_defined_appitem.h"
 #include "system_defined_form.h"
 #include "system_defined_record.h"
+#include "system_defined_pixelmap.h"
 #include "text.h"
 #include "unified_data.h"
 #include "unified_record.h"
@@ -328,7 +329,8 @@ void PasteboardClientUdmfDelayTest::SetPixelMapUnifiedData()
     InitializationOptions opts = { { 5, 7 }, PixelFormat::ARGB_8888, PixelFormat::ARGB_8888 };
     std::unique_ptr<PixelMap> pixelMap = PixelMap::Create(color, sizeof(color) / sizeof(color[0]), opts);
     std::shared_ptr<PixelMap> pixelMapIn = move(pixelMap);
-    std::shared_ptr<UnifiedRecord> record = std::make_shared<UnifiedRecord>(SYSTEM_DEFINED_PIXEL_MAP, pixelMapIn);
+    std::shared_ptr<UnifiedRecord> record =
+        std::make_shared<SystemDefinedPixelMap>(SYSTEM_DEFINED_PIXEL_MAP, pixelMapIn);
     UnifiedData data;
     data.AddRecord(record);
     unifiedData_ = data;
diff --git a/framework/test/src/pasteboard_multi_type_unified_data_delay_test.cpp b/framework/test/src/pasteboard_multi_type_unified_data_delay_test.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..a36b564ce30b07bdbc5784a664b2db5962d825f2
--- /dev/null
+++ b/framework/test/src/pasteboard_multi_type_unified_data_delay_test.cpp
@@ -0,0 +1,372 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+
+#include <variant>
+
+#include "pasteboard_hilog.h"
+#include "pasteboard_client.h"
+#include "pasteboard_error.h"
+
+namespace OHOS::MiscServices {
+using namespace testing;
+using namespace testing::ext;
+using namespace OHOS::UDMF;
+using namespace OHOS::AAFwk;
+using namespace OHOS::Media;
+static std::string text_ = "test";
+static std::string uri_ = "uri";
+static std::string fileType_ = "test";
+static std::string html_ = "<div class='disable'>helloWorld</div>";
+static std::string link_ = "http://abc.com";
+static std::string plainTextUtdId_ = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::PLAIN_TEXT);
+static std::string htmlUtdId_ = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HTML);
+static std::string fileUriUtdId_ = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::FILE_URI);
+static std::string pixelMapUtdId_ = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::SYSTEM_DEFINED_PIXEL_MAP);
+static std::string linkUtdId_ = UDMF::UtdUtils::GetUtdIdFromUtdEnum(UDMF::HYPERLINK);
+class PasteboardMultiTypeUnifiedDataDelayTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+
+    static UDMF::ValueType InitPlainUds();
+    static UDMF::ValueType InitHtmlUds();
+    static UDMF::ValueType InitFileUriUds();
+    static UDMF::ValueType InitPixelMapUds();
+    static UDMF::ValueType InitLinkUds();
+
+    void CheckPlainUds(const UDMF::ValueType &value);
+    void CheckHtmlUds(const UDMF::ValueType &value);
+    void CheckFileUriUds(const UDMF::ValueType &value);
+    void CheckPixelMapUds(const UDMF::ValueType &value);
+    void CheckLinkUds(const UDMF::ValueType &value);
+};
+
+void PasteboardMultiTypeUnifiedDataDelayTest::SetUpTestCase(void)
+{
+    PasteboardClient::GetInstance()->Clear();
+}
+
+void PasteboardMultiTypeUnifiedDataDelayTest::TearDownTestCase(void)
+{
+}
+
+void PasteboardMultiTypeUnifiedDataDelayTest::SetUp()
+{
+}
+
+void PasteboardMultiTypeUnifiedDataDelayTest::TearDown()
+{
+}
+
+UDMF::ValueType PasteboardMultiTypeUnifiedDataDelayTest::InitPlainUds()
+{
+    Object plainUds;
+    plainUds.value_[UDMF::UNIFORM_DATA_TYPE] = plainTextUtdId_;
+    plainUds.value_[UDMF::CONTENT] = text_;
+    return std::make_shared<Object>(plainUds);
+}
+
+UDMF::ValueType PasteboardMultiTypeUnifiedDataDelayTest::InitHtmlUds()
+{
+    Object htmlObject;
+    htmlObject.value_[UDMF::UNIFORM_DATA_TYPE] = htmlUtdId_;
+    htmlObject.value_[UDMF::HTML_CONTENT] = html_;
+    return std::make_shared<Object>(htmlObject);
+}
+
+UDMF::ValueType PasteboardMultiTypeUnifiedDataDelayTest::InitFileUriUds()
+{
+    Object fileUriObject;
+    fileUriObject.value_[UDMF::UNIFORM_DATA_TYPE] = fileUriUtdId_;
+    fileUriObject.value_[UDMF::FILE_URI_PARAM] = uri_;
+    fileUriObject.value_[UDMF::FILE_TYPE] = fileType_;
+    return std::make_shared<Object>(fileUriObject);
+}
+
+UDMF::ValueType PasteboardMultiTypeUnifiedDataDelayTest::InitPixelMapUds()
+{
+    Object object;
+    object.value_[UDMF::UNIFORM_DATA_TYPE] = pixelMapUtdId_;
+    uint32_t color[100] = { 3, 7, 9, 9, 7, 6 };
+    InitializationOptions opts = { { 5, 7 }, PixelFormat::ARGB_8888, PixelFormat::ARGB_8888 };
+    std::unique_ptr<PixelMap> pixelMap = PixelMap::Create(color, sizeof(color) / sizeof(color[0]), opts);
+    std::shared_ptr<PixelMap> pixelMapIn = move(pixelMap);
+    object.value_[UDMF::PIXEL_MAP] = pixelMapIn;
+    return std::make_shared<Object>(object);
+}
+
+UDMF::ValueType PasteboardMultiTypeUnifiedDataDelayTest::InitLinkUds()
+{
+    Object linkObject;
+    linkObject.value_[UDMF::UNIFORM_DATA_TYPE] = linkUtdId_;
+    linkObject.value_[UDMF::URL] = link_;
+    return std::make_shared<Object>(linkObject);
+}
+
+class EntryGetterImpl : public UDMF::EntryGetter {
+public:
+    UDMF::ValueType GetValueByType(const std::string& utdId) override;
+};
+
+UDMF::ValueType EntryGetterImpl::GetValueByType(const std::string& utdId)
+{
+    if (utdId == plainTextUtdId_) {
+        return PasteboardMultiTypeUnifiedDataDelayTest::InitPlainUds();
+    }
+    if (utdId == htmlUtdId_) {
+        return PasteboardMultiTypeUnifiedDataDelayTest::InitHtmlUds();
+    }
+    if (utdId == fileUriUtdId_) {
+        return PasteboardMultiTypeUnifiedDataDelayTest::InitFileUriUds();
+    }
+    if (utdId == pixelMapUtdId_) {
+        return PasteboardMultiTypeUnifiedDataDelayTest::InitPixelMapUds();
+    }
+    if (utdId == linkUtdId_) {
+        return PasteboardMultiTypeUnifiedDataDelayTest::InitLinkUds();
+    }
+    return nullptr;
+}
+
+void PasteboardMultiTypeUnifiedDataDelayTest::CheckPlainUds(const UDMF::ValueType &value)
+{
+    ASSERT_NE(std::get_if<std::shared_ptr<Object>>(&value), nullptr);
+    auto obj = std::get<std::shared_ptr<Object>>(value);
+    ASSERT_NE(obj, nullptr);
+    ASSERT_NE(std::get_if<std::string>(&obj->value_[UDMF::UNIFORM_DATA_TYPE]), nullptr);
+    ASSERT_EQ(std::get<std::string>(obj->value_[UDMF::UNIFORM_DATA_TYPE]), plainTextUtdId_);
+    ASSERT_NE(std::get_if<std::string>(&obj->value_[UDMF::CONTENT]), nullptr);
+    ASSERT_EQ(std::get<std::string>(obj->value_[UDMF::CONTENT]), text_);
+}
+
+void PasteboardMultiTypeUnifiedDataDelayTest::CheckHtmlUds(const UDMF::ValueType &value)
+{
+    ASSERT_NE(std::get_if<std::shared_ptr<Object>>(&value), nullptr);
+    auto obj = std::get<std::shared_ptr<Object>>(value);
+    ASSERT_NE(obj, nullptr);
+    ASSERT_NE(std::get_if<std::string>(&obj->value_[UDMF::UNIFORM_DATA_TYPE]), nullptr);
+    ASSERT_EQ(std::get<std::string>(obj->value_[UDMF::UNIFORM_DATA_TYPE]), htmlUtdId_);
+    ASSERT_NE(std::get_if<std::string>(&obj->value_[UDMF::HTML_CONTENT]), nullptr);
+    ASSERT_EQ(std::get<std::string>(obj->value_[UDMF::HTML_CONTENT]), html_);
+}
+
+void PasteboardMultiTypeUnifiedDataDelayTest::CheckFileUriUds(const UDMF::ValueType &value)
+{
+    ASSERT_NE(std::get_if<std::shared_ptr<Object>>(&value), nullptr);
+    auto obj = std::get<std::shared_ptr<Object>>(value);
+    ASSERT_NE(obj, nullptr);
+    ASSERT_NE(std::get_if<std::string>(&obj->value_[UDMF::UNIFORM_DATA_TYPE]), nullptr);
+    ASSERT_EQ(std::get<std::string>(obj->value_[UDMF::UNIFORM_DATA_TYPE]), fileUriUtdId_);
+    ASSERT_NE(std::get_if<std::string>(&obj->value_[UDMF::FILE_URI_PARAM]), nullptr);
+    ASSERT_EQ(std::get<std::string>(obj->value_[UDMF::FILE_URI_PARAM]), uri_);
+    ASSERT_NE(std::get_if<std::string>(&obj->value_[UDMF::FILE_TYPE]), nullptr);
+    ASSERT_EQ(std::get<std::string>(obj->value_[UDMF::FILE_TYPE]), fileType_);
+}
+
+void PasteboardMultiTypeUnifiedDataDelayTest::CheckPixelMapUds(const UDMF::ValueType &value)
+{
+    ASSERT_NE(std::get_if<std::shared_ptr<Object>>(&value), nullptr);
+    auto obj = std::get<std::shared_ptr<Object>>(value);
+    ASSERT_NE(std::get_if<std::string>(&obj->value_[UDMF::UNIFORM_DATA_TYPE]), nullptr);
+    ASSERT_EQ(std::get<std::string>(obj->value_[UDMF::UNIFORM_DATA_TYPE]), pixelMapUtdId_);
+    auto pixelMap = std::get_if<std::shared_ptr<PixelMap>>(&obj->value_[UDMF::PIXEL_MAP]);
+    ASSERT_NE(pixelMap, nullptr);
+    ImageInfo imageInfo = {};
+    (*pixelMap)->GetImageInfo(imageInfo);
+    ASSERT_EQ(imageInfo.size.height, 7);
+    ASSERT_EQ(imageInfo.size.width, 5);
+    ASSERT_EQ(imageInfo.pixelFormat, PixelFormat::ARGB_8888);
+}
+
+void PasteboardMultiTypeUnifiedDataDelayTest::CheckLinkUds(const UDMF::ValueType &value)
+{
+    ASSERT_NE(std::get_if<std::shared_ptr<Object>>(&value), nullptr);
+    auto obj = std::get<std::shared_ptr<Object>>(value);
+    ASSERT_NE(obj, nullptr);
+    ASSERT_NE(std::get_if<std::string>(&obj->value_[UDMF::UNIFORM_DATA_TYPE]), nullptr);
+    ASSERT_EQ(std::get<std::string>(obj->value_[UDMF::UNIFORM_DATA_TYPE]), linkUtdId_);
+    ASSERT_NE(std::get_if<std::string>(&obj->value_[UDMF::URL]), nullptr);
+    ASSERT_EQ(std::get<std::string>(obj->value_[UDMF::URL]), link_);
+}
+
+/**
+ * @tc.name: SetMultiTypeUnifiedDataDelayTest001
+ * @tc.desc: add empty entry with entry getter to pasteboard
+ * @tc.type: FUNC
+ */
+HWTEST_F(PasteboardMultiTypeUnifiedDataDelayTest, SetMultiTypeUnifiedDataDelayTest001, TestSize.Level1)
+{
+    UnifiedData inputData;
+    std::shared_ptr<UnifiedRecord> inputRecord = std::make_shared<UnifiedRecord>();
+    std::set<std::string> inputTypes;
+    inputTypes.insert(plainTextUtdId_);
+    inputTypes.insert(htmlUtdId_);
+    inputTypes.insert(fileUriUtdId_);
+    inputTypes.insert(pixelMapUtdId_);
+    inputTypes.insert(linkUtdId_);
+    std::shared_ptr<EntryGetter> entryGetter = std::make_shared<EntryGetterImpl>();
+    inputRecord->SetEntryGetter(inputTypes, entryGetter);
+    inputData.AddRecord(inputRecord);
+    auto status = PasteboardClient::GetInstance()->SetUdsdData(inputData);
+    ASSERT_EQ(status, static_cast<int32_t>(PasteboardError::E_OK));
+
+    UnifiedData outputData;
+    status = PasteboardClient::GetInstance()->GetUdsdData(outputData);
+    ASSERT_EQ(status, static_cast<int32_t>(PasteboardError::E_OK));
+    auto inputRecords = inputData.GetRecords();
+    auto outputRecords = outputData.GetRecords();
+    ASSERT_EQ(outputRecords.size(), inputRecords.size());
+    auto outputRecord = outputData.GetRecordAt(0);
+    ASSERT_NE(outputRecord, nullptr);
+    auto outputTypes = outputRecord->GetUtdIds();
+    ASSERT_EQ(outputTypes.size(), inputTypes.size());
+
+    ASSERT_TRUE(outputTypes.find(plainTextUtdId_) != outputTypes.end());
+    CheckPlainUds(outputRecord->GetEntry(plainTextUtdId_));
+
+    ASSERT_TRUE(outputTypes.find(htmlUtdId_) != outputTypes.end());
+    CheckHtmlUds(outputRecord->GetEntry(htmlUtdId_));
+
+    ASSERT_TRUE(outputTypes.find(fileUriUtdId_) != outputTypes.end());
+    CheckFileUriUds(outputRecord->GetEntry(fileUriUtdId_));
+
+    ASSERT_TRUE(outputTypes.find(pixelMapUtdId_) != outputTypes.end());
+    CheckPixelMapUds(outputRecord->GetEntry(pixelMapUtdId_));
+
+    ASSERT_TRUE(outputTypes.find(linkUtdId_) != outputTypes.end());
+    CheckLinkUds(outputRecord->GetEntry(linkUtdId_));
+}
+
+/**
+ * @tc.name: SetMultiTypeUnifiedDataDelayTest002
+ * @tc.desc: add empty and valid entry with entry getter to pasteboard
+ * @tc.type: FUNC
+ */
+HWTEST_F(PasteboardMultiTypeUnifiedDataDelayTest, SetMultiTypeUnifiedDataDelayTest002, TestSize.Level1)
+{
+    UnifiedData inputData;
+    std::shared_ptr<UnifiedRecord> inputRecord = std::make_shared<UnifiedRecord>();
+    inputRecord->AddEntry(plainTextUtdId_, InitPlainUds());
+    inputRecord->AddEntry(pixelMapUtdId_, InitPixelMapUds());
+    std::set<std::string> inputTypes;
+    inputTypes.insert(htmlUtdId_);
+    inputTypes.insert(fileUriUtdId_);
+    inputTypes.insert(linkUtdId_);
+    std::shared_ptr<EntryGetter> entryGetter = std::make_shared<EntryGetterImpl>();
+    inputRecord->SetEntryGetter(inputTypes, entryGetter);
+    inputData.AddRecord(inputRecord);
+    auto status = PasteboardClient::GetInstance()->SetUdsdData(inputData);
+    ASSERT_EQ(status, static_cast<int32_t>(PasteboardError::E_OK));
+
+    UnifiedData outputData;
+    status = PasteboardClient::GetInstance()->GetUdsdData(outputData);
+    ASSERT_EQ(status, static_cast<int32_t>(PasteboardError::E_OK));
+    auto inputRecords = inputData.GetRecords();
+    auto outputRecords = outputData.GetRecords();
+    ASSERT_EQ(outputRecords.size(), inputRecords.size());
+    auto outputRecord = outputData.GetRecordAt(0);
+    ASSERT_NE(outputRecord, nullptr);
+    auto outputTypes = outputRecord->GetUtdIds();
+    auto tempTypes = inputRecord->GetUtdIds();
+    ASSERT_EQ(outputTypes.size(), tempTypes.size());
+
+    ASSERT_TRUE(outputTypes.find(plainTextUtdId_) != outputTypes.end());
+    CheckPlainUds(outputRecord->GetEntry(plainTextUtdId_));
+
+    ASSERT_TRUE(outputTypes.find(htmlUtdId_) != outputTypes.end());
+    CheckHtmlUds(outputRecord->GetEntry(htmlUtdId_));
+
+    ASSERT_TRUE(outputTypes.find(fileUriUtdId_) != outputTypes.end());
+    CheckFileUriUds(outputRecord->GetEntry(fileUriUtdId_));
+
+    ASSERT_TRUE(outputTypes.find(pixelMapUtdId_) != outputTypes.end());
+    CheckPixelMapUds(outputRecord->GetEntry(pixelMapUtdId_));
+
+    ASSERT_TRUE(outputTypes.find(linkUtdId_) != outputTypes.end());
+    CheckLinkUds(outputRecord->GetEntry(linkUtdId_));
+}
+
+/**
+ * @tc.name: SetMultiTypeUnifiedDataDelayTest003
+ * @tc.desc: add more unified record with entry getter to pasteboard
+ * @tc.type: FUNC
+ */
+HWTEST_F(PasteboardMultiTypeUnifiedDataDelayTest, SetMultiTypeUnifiedDataDelayTest003, TestSize.Level1)
+{
+    UnifiedData inputData;
+
+    std::shared_ptr<UnifiedRecord> inputRecord1 = std::make_shared<UnifiedRecord>();
+    std::set<std::string> inputTypes1;
+    inputTypes1.insert(plainTextUtdId_);
+    inputTypes1.insert(htmlUtdId_);
+    std::shared_ptr<EntryGetter> entryGetter1 = std::make_shared<EntryGetterImpl>();
+    inputRecord1->SetEntryGetter(inputTypes1, entryGetter1);
+    inputData.AddRecord(inputRecord1);
+
+    std::shared_ptr<UnifiedRecord> inputRecord2 = std::make_shared<UnifiedRecord>();
+    std::set<std::string> inputTypes2;
+    inputTypes2.insert(fileUriUtdId_);
+    inputTypes2.insert(pixelMapUtdId_);
+    std::shared_ptr<EntryGetter> entryGetter2 = std::make_shared<EntryGetterImpl>();
+    inputRecord2->SetEntryGetter(inputTypes2, entryGetter2);
+    inputData.AddRecord(inputRecord2);
+
+    std::shared_ptr<UnifiedRecord> inputRecord3 = std::make_shared<UnifiedRecord>();
+    std::set<std::string> inputTypes3;
+    inputTypes3.insert(linkUtdId_);
+    std::shared_ptr<EntryGetter> entryGetter3 = std::make_shared<EntryGetterImpl>();
+    inputRecord3->SetEntryGetter(inputTypes3, entryGetter3);
+    inputData.AddRecord(inputRecord3);
+
+    auto status = PasteboardClient::GetInstance()->SetUdsdData(inputData);
+    ASSERT_EQ(status, static_cast<int32_t>(PasteboardError::E_OK));
+
+    UnifiedData outputData;
+    status = PasteboardClient::GetInstance()->GetUdsdData(outputData);
+    ASSERT_EQ(status, static_cast<int32_t>(PasteboardError::E_OK));
+    auto inputRecords = inputData.GetRecords();
+    auto outputRecords = outputData.GetRecords();
+    ASSERT_EQ(outputRecords.size(), inputRecords.size());
+
+    auto outputRecord1 = outputData.GetRecordAt(0);
+    ASSERT_NE(outputRecord1, nullptr);
+    auto outputTypes1 = outputRecord1->GetUtdIds();
+    ASSERT_EQ(outputTypes1.size(), inputTypes1.size());
+    ASSERT_TRUE(outputTypes1.find(plainTextUtdId_) != outputTypes1.end());
+    CheckPlainUds(outputRecord1->GetEntry(plainTextUtdId_));
+    ASSERT_TRUE(outputTypes1.find(htmlUtdId_) != outputTypes1.end());
+    CheckHtmlUds(outputRecord1->GetEntry(htmlUtdId_));
+
+    auto outputRecord2 = outputData.GetRecordAt(1);
+    ASSERT_NE(outputRecord2, nullptr);
+    auto outputTypes2 = outputRecord2->GetUtdIds();
+    ASSERT_EQ(outputTypes2.size(), inputTypes2.size());
+    ASSERT_TRUE(outputTypes2.find(fileUriUtdId_) != outputTypes2.end());
+    CheckFileUriUds(outputRecord2->GetEntry(fileUriUtdId_));
+    ASSERT_TRUE(outputTypes2.find(pixelMapUtdId_) != outputTypes2.end());
+    CheckPixelMapUds(outputRecord2->GetEntry(pixelMapUtdId_));
+
+    auto outputRecord3 = outputData.GetRecordAt(2);
+    ASSERT_NE(outputRecord3, nullptr);
+    auto outputTypes3 = outputRecord3->GetUtdIds();
+    ASSERT_EQ(outputTypes3.size(), inputTypes3.size());
+    ASSERT_TRUE(outputTypes3.find(linkUtdId_) != outputTypes3.end());
+    CheckLinkUds(outputRecord3->GetEntry(linkUtdId_));
+}
+} // OHOS::MiscServices
\ No newline at end of file
diff --git a/framework/test/src/pasteboard_unified_data_test.cpp b/framework/test/src/pasteboard_unified_data_test.cpp
index 5021781c02747bf66b25cf3abd7bdb9cb06b704a..c2af5dfc46feeaca277002b193e0e82fb21342f3 100644
--- a/framework/test/src/pasteboard_unified_data_test.cpp
+++ b/framework/test/src/pasteboard_unified_data_test.cpp
@@ -25,6 +25,7 @@
 #include "plain_text.h"
 #include "system_defined_appitem.h"
 #include "system_defined_form.h"
+#include "system_defined_pixelmap.h"
 #include "video.h"
 namespace OHOS::MiscServices {
 using namespace testing::ext;
@@ -237,7 +238,7 @@ UDMF::UnifiedData PasteboardUnifiedDataTest::InitSystemPixelMapData()
     std::unique_ptr<PixelMap> pixelMap = PixelMap::Create(color, sizeof(color) / sizeof(color[0]), opts);
     std::shared_ptr<PixelMap> pixelMapIn = move(pixelMap);
     std::shared_ptr<UDMF::UnifiedRecord> pixelMapRecord =
-        std::make_shared<UDMF::UnifiedRecord>(UDMF::SYSTEM_DEFINED_PIXEL_MAP, pixelMapIn);
+        std::make_shared<UDMF::SystemDefinedPixelMap>(UDMF::SYSTEM_DEFINED_PIXEL_MAP, pixelMapIn);
     UDMF::UnifiedData data;
     data.AddRecord(pixelMapRecord);
     return data;
diff --git a/framework/test/src/pasteboard_utils_test.cpp b/framework/test/src/pasteboard_utils_test.cpp
index bf1c16a5f194e1bfc344f62adc2c7d1bee6b3433..291a76ad455a1055805446b30f633b26241d33b3 100644
--- a/framework/test/src/pasteboard_utils_test.cpp
+++ b/framework/test/src/pasteboard_utils_test.cpp
@@ -26,6 +26,7 @@
 #include "plain_text.h"
 #include "system_defined_appitem.h"
 #include "system_defined_form.h"
+#include "system_defined_pixelmap.h"
 #include "video.h"
 namespace OHOS::MiscServices {
 using namespace testing::ext;
@@ -238,7 +239,7 @@ UDMF::UnifiedData PasteboardUtilsTest::InitSystemPixelMapData()
     std::unique_ptr<PixelMap> pixelMap = PixelMap::Create(color, sizeof(color) / sizeof(color[0]), opts);
     std::shared_ptr<PixelMap> pixelMapIn = move(pixelMap);
     std::shared_ptr<UDMF::UnifiedRecord> pixelMapRecord =
-        std::make_shared<UDMF::UnifiedRecord>(UDMF::SYSTEM_DEFINED_PIXEL_MAP, pixelMapIn);
+        std::make_shared<UDMF::SystemDefinedPixelMap>(UDMF::SYSTEM_DEFINED_PIXEL_MAP, pixelMapIn);
     UDMF::UnifiedData data;
     data.AddRecord(pixelMapRecord);
     return data;
diff --git a/framework/tlv/BUILD.gn b/framework/tlv/BUILD.gn
index 80e66aee45aa0df073705f1a3b9987462c94bcd5..44efa36e331ba320d8c727e020f615e78c47f87c 100644
--- a/framework/tlv/BUILD.gn
+++ b/framework/tlv/BUILD.gn
@@ -46,6 +46,7 @@ ohos_static_library("pasteboard_tlv") {
   external_deps = [
     "c_utils:utils",
     "hilog:libhilog",
+    "udmf:udmf_client",
   ]
   subsystem_name = "distributeddatamgr"
   part_name = "pasteboard"
diff --git a/framework/tlv/parcel_util.h b/framework/tlv/parcel_util.h
index 41c3b27743de9e238489d4915e56d480cb1e582d..3c37a9b2e6dfee0389fb9b0b762746c748ae36c4 100644
--- a/framework/tlv/parcel_util.h
+++ b/framework/tlv/parcel_util.h
@@ -19,9 +19,15 @@
 #include "api/visibility.h"
 #include "parcel.h"
 #include "securec.h"
-#include "tlv_object.h"
 namespace OHOS::MiscServices {
 
+struct RawMem {
+    uintptr_t buffer;
+    size_t bufferLen;
+    // notice:Keep the parcel reference to prevent the memory in the parcel from being destructed
+    std::shared_ptr<OHOS::Parcel> parcel;
+};
+
 class ParcelUtil {
 public:
     // parcelable to buffer
diff --git a/framework/tlv/tlv_object.cpp b/framework/tlv/tlv_object.cpp
index 62b8e419e0ce20aec2f183dada7b5db0a40f28a8..8a990b54d0ba574d217d4ddfda1afd7ddd8b2939 100644
--- a/framework/tlv/tlv_object.cpp
+++ b/framework/tlv/tlv_object.cpp
@@ -15,7 +15,26 @@
 #include "tlv_object.h"
 
 #include "securec.h"
+#include "unified_meta.h"
+#include "want.h"
 namespace OHOS::MiscServices {
+
+bool TLVObject::Write(std::vector<std::uint8_t> &buffer, uint16_t type, std::monostate value)
+{
+    if (!HasExpectBuffer(buffer, sizeof(TLVHead))) {
+        return false;
+    }
+    cursor_ += sizeof(TLVHead);
+    return true;
+}
+bool TLVObject::Write(std::vector<std::uint8_t> &buffer, uint16_t type, void* value)
+{
+    if (!HasExpectBuffer(buffer, sizeof(TLVHead))) {
+        return false;
+    }
+    cursor_ += sizeof(TLVHead);
+    return true;
+}
 bool TLVObject::Write(std::vector<std::uint8_t> &buffer, uint16_t type, bool value)
 {
     return WriteBasic(buffer, type, (int8_t)(value));
@@ -83,6 +102,41 @@ bool TLVObject::Write(std::vector<std::uint8_t> &buffer, uint16_t type, const Ra
     tlvHead->len = HostToNet((uint32_t)value.bufferLen);
     return true;
 }
+
+bool TLVObject::Write(std::vector<std::uint8_t> &buffer, uint16_t type, const AAFwk::Want &value)
+{
+    return Write(buffer, type, ParcelUtil::Parcelable2Raw(&value));
+}
+
+bool TLVObject::Write(std::vector<std::uint8_t> &buffer, uint16_t type, const Media::PixelMap &value)
+{
+    std::vector<std::uint8_t> u8Value;
+    if (!value.EncodeTlv(u8Value)) {
+        return false;
+    }
+    return Write(buffer, type, u8Value);
+}
+
+bool TLVObject::Write(std::vector<std::uint8_t> &buffer, uint16_t type, const Object &value)
+{
+    if (!HasExpectBuffer(buffer, sizeof(TLVHead))) {
+        return false;
+    }
+    auto tagCursor = cursor_;
+    cursor_ += sizeof(TLVHead);
+    auto valueCursor = cursor_;
+    for (const auto& [key, val] : value.value_) {
+        if (!Write(buffer, TAG_MAP_KEY, key)) {
+            return false;
+        }
+        if (!Write(buffer, TAG_MAP_VALUE_TYPE, val)) {
+            return false;
+        }
+    }
+    WriteHead(buffer, type, tagCursor, cursor_ - valueCursor);
+    return true;
+}
+
 bool TLVObject::Write(
     std::vector<std::uint8_t> &buffer, uint16_t type, std::map<std::string, std::vector<uint8_t>> &value)
 {
@@ -121,12 +175,20 @@ bool TLVObject::WriteVariant(std::vector<std::uint8_t>& buffer, uint16_t type, u
 template<typename... _Types>
 bool TLVObject::Write(std::vector<std::uint8_t>& buffer, uint16_t type, const std::variant<_Types...> &input)
 {
-    uint32_t index = static_cast<uint32_t>(input.index());
-    if (!Write(buffer, TAG_MAP_VALUE_TYPE_INDEX, index)) {
+    if (!HasExpectBuffer(buffer, sizeof(TLVHead))) {
         return false;
     }
+    auto tagCursor = cursor_;
+    cursor_ += sizeof(TLVHead);
+    auto valueCursor = cursor_;
 
-    return WriteVariant<decltype(input), _Types...>(buffer, TAG_MAP_VALUE_TYPE_VALUE, 0, input);
+    uint32_t index = static_cast<uint32_t>(input.index());
+    if (!Write(buffer, TAG_VARIANT_INDEX, index)) {
+        return false;
+    }
+    WriteVariant<decltype(input), _Types...>(buffer, TAG_VARIANT_VALUE, 0, input);
+    WriteHead(buffer, type, tagCursor, cursor_ - valueCursor);
+    return true;
 }
 
 bool TLVObject::Write(std::vector<std::uint8_t>& buffer, uint16_t type, const Details& value)
@@ -137,7 +199,7 @@ bool TLVObject::Write(std::vector<std::uint8_t>& buffer, uint16_t type, const De
     auto tagCursor = cursor_;
     cursor_ += sizeof(TLVHead);
     auto valueCursor = cursor_;
-    for (auto [key, val] : value) {
+    for (auto &[key, val] : value) {
         if (!Write(buffer, TAG_MAP_KEY, key)) {
             return false;
         }
@@ -194,6 +256,14 @@ bool TLVObject::ReadHead(const std::vector<std::uint8_t> &buffer, TLVHead &head)
     cursor_ += sizeof(TLVHead);
     return true;
 }
+bool TLVObject::ReadValue(const std::vector<std::uint8_t> &buffer, std::monostate &value, const TLVHead &head)
+{
+    return true;
+}
+bool TLVObject::ReadValue(const std::vector<std::uint8_t> &buffer, void *value, const TLVHead &head)
+{
+    return true;
+}
 bool TLVObject::ReadValue(const std::vector<std::uint8_t> &buffer, bool &value, const TLVHead &head)
 {
     return ReadBasicValue(buffer, value, head);
@@ -242,6 +312,7 @@ bool TLVObject::ReadValue(const std::vector<std::uint8_t> &buffer, RawMem &rawMe
     cursor_ += head.len;
     return true;
 }
+
 bool TLVObject::ReadValue(const std::vector<std::uint8_t> &buffer, TLVObject &value, const TLVHead &head)
 {
     return value.Decode(buffer, cursor_, cursor_ + head.len);
@@ -326,8 +397,12 @@ bool TLVObject::ReadValue(const std::vector<std::uint8_t>& buffer, Details& valu
         if (!ReadValue(buffer, itemKey, keyHead)) {
             return false;
         }
+        TLVHead variantHead{};
+        if (!ReadHead(buffer, variantHead)) {
+            return false;
+        }
         ValueType itemValue;
-        if (!ReadValue(buffer, itemValue, head)) {
+        if (!ReadValue(buffer, itemValue, variantHead)) {
             return false;
         }
         value.emplace(itemKey, itemValue);
@@ -335,6 +410,52 @@ bool TLVObject::ReadValue(const std::vector<std::uint8_t>& buffer, Details& valu
     return true;
 }
 
+bool TLVObject::ReadValue(const std::vector<std::uint8_t> &buffer, Object &value, const TLVHead &head)
+{
+    auto mapEnd = cursor_ + head.len;
+    while (cursor_ < mapEnd) {
+        TLVHead keyHead{};
+        if (!ReadHead(buffer, keyHead)) {
+            return false;
+        }
+        std::string itemKey = "";
+        if (!ReadValue(buffer, itemKey, keyHead)) {
+            return false;
+        }
+        TLVHead valueHead{};
+        if (!ReadHead(buffer, valueHead)) {
+            return false;
+        }
+        EntryValue itemValue;
+        if (!ReadValue(buffer, itemValue, head)) {
+            return false;
+        }
+        value.value_.emplace(itemKey, itemValue);
+    }
+    return true;
+}
+
+bool TLVObject::ReadValue(const std::vector<std::uint8_t> &buffer, AAFwk::Want &value, const TLVHead &head)
+{
+    RawMem rawMem{};
+    if (!ReadValue(buffer, rawMem, head)) {
+        return false;
+    }
+    value = *(ParcelUtil::Raw2Parcelable<AAFwk::Want>(rawMem));
+    return true;
+}
+
+bool TLVObject::ReadValue(const std::vector<std::uint8_t> &buffer, std::shared_ptr<Media::PixelMap> &value,
+    const TLVHead &head)
+{
+    std::vector<std::uint8_t> u8Value;
+    if (!ReadValue(buffer, u8Value, head)) {
+        return false;
+    }
+    value = Vector2PixelMap(u8Value);
+    return true;
+}
+
 bool TLVObject::Encode(std::vector<std::uint8_t> &buffer, size_t &cursor, size_t total)
 {
     cursor_ = cursor;
@@ -351,4 +472,24 @@ bool TLVObject::Decode(const std::vector<std::uint8_t> &buffer, size_t &cursor,
     cursor = cursor_;
     return ret;
 }
+
+std::shared_ptr<Media::PixelMap> TLVObject::Vector2PixelMap(std::vector<std::uint8_t> &value)
+{
+    if (value.size() == 0) {
+        return nullptr;
+    }
+    return std::shared_ptr<Media::PixelMap> (Media::PixelMap::DecodeTlv(value));
+}
+
+std::vector<std::uint8_t> TLVObject::PixelMap2Vector(std::shared_ptr<Media::PixelMap> pixelMap)
+{
+    if (pixelMap == nullptr) {
+        return {};
+    }
+    std::vector<std::uint8_t> value;
+    if (!pixelMap->EncodeTlv(value)) {
+        return {};
+    }
+    return value;
+}
 } // namespace OHOS::MiscServices
diff --git a/framework/tlv/tlv_object.h b/framework/tlv/tlv_object.h
index a0a8f5625e7a0f4f9c437a82294c19cd211cc37c..5a2c7a4818204e20807816a7a5e4c0d70a29ab5e 100644
--- a/framework/tlv/tlv_object.h
+++ b/framework/tlv/tlv_object.h
@@ -26,7 +26,8 @@
 #include "endian_converter.h"
 #include "parcel.h"
 #include "securec.h"
-
+#include "unified_meta.h"
+#include "parcel_util.h"
 namespace OHOS::MiscServices {
 #pragma pack(1)
 struct TLVHead {
@@ -35,12 +36,6 @@ struct TLVHead {
     std::uint8_t value[0];
 };
 #pragma pack()
-struct RawMem {
-    uintptr_t buffer;
-    size_t bufferLen;
-    // notice:Keep the parcel reference to prevent the memory in the parcel from being destructed
-    std::shared_ptr<OHOS::Parcel> parcel;
-};
 
 /*
  * Common tag definitions.
@@ -51,14 +46,17 @@ enum COMMON_TAG : uint16_t {
     TAG_MAP_KEY,
     TAG_MAP_VALUE, // std::vector<uint8_t>
     TAG_MAP_VALUE_TYPE,
-    TAG_MAP_VALUE_TYPE_INDEX,
-    TAG_MAP_VALUE_TYPE_VALUE,
+    TAG_VARIANT_INDEX,
+    TAG_VARIANT_VALUE,
     TAG_BUFF = 0x0100,
 };
 
 using ValueType = std::variant<int32_t, int64_t, bool, double, std::string, std::vector<uint8_t>>;
 using Details = std::map<std::string, ValueType>;
 
+using EntryValue = UDMF::ValueType;
+using Object = UDMF::Object;
+
 struct API_EXPORT TLVObject {
 public:
     TLVObject() : total_(0), cursor_(0)
@@ -67,7 +65,6 @@ public:
     virtual bool Encode(std::vector<std::uint8_t> &buffer) = 0;
     virtual bool Decode(const std::vector<std::uint8_t> &buffer) = 0;
     virtual size_t Count() = 0;
-
     inline void Init(std::vector<std::uint8_t> &buffer)
     {
         buffer.resize(Count());
@@ -147,6 +144,7 @@ public:
         }
         return expectSize;
     }
+
     static inline size_t Count(const Details& value)
     {
         size_t expectSize = sizeof(TLVHead);
@@ -157,6 +155,50 @@ public:
         return expectSize;
     }
 
+    static inline size_t Count(const std::shared_ptr<AAFwk::Want>& value)
+    {
+        size_t expectSize = sizeof(TLVHead);
+        if (value == nullptr) {
+            return 0;
+        }
+        return expectSize + Count(ParcelUtil::Parcelable2Raw(value.get()));
+    }
+
+    static inline size_t Count(std::shared_ptr<Media::PixelMap> value)
+    {
+        size_t expectSize = sizeof(TLVHead);
+        if (value == nullptr) {
+            return 0;
+        }
+        return expectSize + Count(PixelMap2Vector(value));
+    }
+
+    static inline size_t Count(const std::shared_ptr<Object>& value)
+    {
+        size_t expectSize = sizeof(TLVHead);
+        if (value == nullptr) {
+            return 0;
+        }
+        for (auto& item : value->value_) {
+            expectSize += Count(item.first);
+            expectSize += Count(item.second);
+        }
+        return expectSize;
+    }
+
+    static inline size_t Count(const std::monostate &value)
+    {
+        return sizeof(TLVHead);
+    }
+
+    static inline size_t Count(const void *value)
+    {
+        return sizeof(TLVHead);
+    }
+
+    static std::shared_ptr<Media::PixelMap> Vector2PixelMap(std::vector<std::uint8_t> &value);
+    static std::vector<std::uint8_t> PixelMap2Vector(std::shared_ptr<Media::PixelMap> pixelMap);
+
     template<typename _InTp>
     static inline size_t CountVariant(uint32_t step, const _InTp& input)
     {
@@ -175,9 +217,12 @@ public:
     template<typename... _Types>
     static inline size_t Count(const std::variant<_Types...>& input)
     {
-        return CountVariant<decltype(input), _Types...>(0, input);
+        size_t expectSize = sizeof(TLVHead);
+        return expectSize + CountVariant<decltype(input), _Types...>(0, input);
     }
 
+    bool Write(std::vector<std::uint8_t> &buffer, uint16_t type, std::monostate value);
+    bool Write(std::vector<std::uint8_t> &buffer, uint16_t type, void* value);
     bool Write(std::vector<std::uint8_t> &buffer, uint16_t type, bool value);
     bool Write(std::vector<std::uint8_t> &buffer, uint16_t type, double value);
     bool Write(std::vector<std::uint8_t> &buffer, uint16_t type, int8_t value);
@@ -186,6 +231,9 @@ public:
     bool Write(std::vector<std::uint8_t> &buffer, uint16_t type, int64_t value);
     bool Write(std::vector<std::uint8_t> &buffer, uint16_t type, uint32_t value);
     bool Write(std::vector<std::uint8_t> &buffer, uint16_t type, const std::string &value);
+    bool Write(std::vector<std::uint8_t> &buffer, uint16_t type, const Object &value);
+    bool Write(std::vector<std::uint8_t> &buffer, uint16_t type, const AAFwk::Want &value);
+    bool Write(std::vector<std::uint8_t> &buffer, uint16_t type, const Media::PixelMap &value);
     bool Write(std::vector<std::uint8_t> &buffer, uint16_t type, const RawMem &value);
     bool Write(std::vector<std::uint8_t> &buffer, uint16_t type, TLVObject &value);
     template<typename T>
@@ -225,6 +273,8 @@ public:
 
     bool ReadHead(const std::vector<std::uint8_t> &buffer, TLVHead &head);
     bool ReadValue(const std::vector<std::uint8_t> &buffer, bool &value, const TLVHead &head);
+    bool ReadValue(const std::vector<std::uint8_t> &buffer, std::monostate &value, const TLVHead &head);
+    bool ReadValue(const std::vector<std::uint8_t> &buffer, void *value, const TLVHead &head);
     bool ReadValue(const std::vector<std::uint8_t> &buffer, int8_t &value, const TLVHead &head);
     bool ReadValue(const std::vector<std::uint8_t> &buffer, int16_t &value, const TLVHead &head);
     bool ReadValue(const std::vector<std::uint8_t> &buffer, int32_t &value, const TLVHead &head);
@@ -233,6 +283,10 @@ public:
     bool ReadValue(const std::vector<std::uint8_t> &buffer, uint32_t &value, const TLVHead &head);
     bool ReadValue(const std::vector<std::uint8_t> &buffer, std::string &value, const TLVHead &head);
     bool ReadValue(const std::vector<std::uint8_t> &buffer, RawMem &rawMem, const TLVHead &head);
+    bool ReadValue(const std::vector<std::uint8_t> &buffer, Object &value, const TLVHead &head);
+    bool ReadValue(const std::vector<std::uint8_t> &buffer, AAFwk::Want &value, const TLVHead &head);
+    bool ReadValue(const std::vector<std::uint8_t> &buffer, std::shared_ptr<Media::PixelMap> &value,
+        const TLVHead &head);
     bool ReadValue(const std::vector<std::uint8_t> &buffer, TLVObject &value, const TLVHead &head);
     template<typename T>
     bool ReadValue(const std::vector<std::uint8_t> &buffer, std::vector<T> &value, const TLVHead &head)
diff --git a/interfaces/ndk/BUILD.gn b/interfaces/ndk/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..bcf504d1928c88c8a19868b4dadd3fa1dbc5318f
--- /dev/null
+++ b/interfaces/ndk/BUILD.gn
@@ -0,0 +1,53 @@
+# Copyright (c) 2024 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+import("//build/ohos.gni")
+import("//foundation/distributeddatamgr/pasteboard/pasteboard.gni")
+
+ohos_shared_library("libpasteboard") {
+  branch_protector_ret = "pac_ret"
+  sanitize = {
+    cfi = true
+    cfi_cross_dso = true
+    debug = false
+  }
+
+  include_dirs = [
+    "${pasteboard_interfaces_path}/ndk/include",
+    "${pasteboard_framework_path}/innerkits/include",
+    "${pasteboard_interfaces_path}/kits/napi/include",
+    "${pasteboard_framework_path}/framework/include",
+    "${pasteboard_service_path}/core/include",
+  ]
+  sources = [
+    "${pasteboard_interfaces_path}/ndk/src/oh_pasteboard.cpp",
+    "${pasteboard_interfaces_path}/ndk/src/oh_pasteboard_observer_impl.cpp",
+  ]
+
+  defines = [ "API_EXPORT=__attribute__((visibility (\"default\")))" ]
+
+  deps = [ "${pasteboard_root_path}/framework/innerkits:pasteboard_client" ]
+
+  external_deps = [
+    "ability_base:base",
+    "ability_base:want",
+    "c_utils:utils",
+    "hilog:libhilog",
+    "ipc:ipc_single",
+    "udmf:libudmf",
+  ]
+
+  relative_install_dir = "ndk"
+  part_name = "pasteboard"
+  subsystem_name = "distributeddatamgr"
+  output_extension = "so"
+}
diff --git a/interfaces/ndk/include/oh_pasteboard.h b/interfaces/ndk/include/oh_pasteboard.h
new file mode 100644
index 0000000000000000000000000000000000000000..e59d70e6c078238b6c435be579ec2244c9967987
--- /dev/null
+++ b/interfaces/ndk/include/oh_pasteboard.h
@@ -0,0 +1,281 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @addtogroup Pasteboard
+ * @{
+ *
+ * @brief Provides the copy and paste support for the system Pasteboard.
+ * You can use the APIs of this module to operate the Pasteboard content of the plain text, HTML,
+ * URI, Want, pixel map, and other types.
+ *
+ * @since 13
+ */
+
+/**
+ * @file OH_Pasteboard.h
+ *
+ * @brief Provides APIs and enums of the Pasteboard module.
+ *
+ * @kit BasicServicesKit
+ * @library libpasteboard_ndk.so
+ * @syscap SystemCapability.MiscServices.Pasteboard
+ *
+ * @since 13
+ */
+
+#ifndef OH_PASTEBOARD_H
+#define OH_PASTEBOARD_H
+
+#include <inttypes.h>
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Introduces the UDMF data defined by ArkData Kit.
+ *
+ * @since 13
+ */
+struct OH_UdmfData;
+
+/**
+ * @brief Enumerates the types of data changes that can be observed.
+ *
+ * @since 13
+ */
+typedef enum Pasteboard_NotifyType {
+    /**
+     * @brief Change of the Pasteboard data in the local device.
+     */
+    NOTIFY_LOCAL_DATA_CHANGE = 1,
+    /**
+     * @brief Change of the Pasteboard data in the remote devices.
+     */
+    NOTIFY_REMOTE_DATA_CHANGE = 2
+} Pasteboard_NotifyType;
+
+/**
+ * @brief Defines the callback function used to return the Pasteboard data changed.
+ *
+ * @param context The context set by {@link OH_PasteboardObserver_SetData} function.
+ * @param type The types of data changes. For details, see {@link Pasteboard_NotifyType}.
+ * @since 13
+ */
+typedef void (*Pasteboard_Notify)(void* context, Pasteboard_NotifyType type);
+
+/**
+ * @brief Defines the callback function used free the context.
+ * @param context Pointer to the context which is to be free.
+ * @since 13
+ */
+typedef void (*Pasteboard_Finalize)(void* context);
+
+/**
+ * @brief Defines the Pasteboard subscriber information
+ *
+ * @since 13
+ */
+typedef struct OH_PasteboardObserver OH_PasteboardObserver;
+
+/**
+ * @brief Creates a {@link OH_PasteboardObserver} instance.
+ *
+ * @return Returns the pointer to the {@link OH_PasteboardObserver} instance created if the operation is successful.
+ * Returns nullptr if the memory is not enough.
+ * @see OH_PasteboardObserver.
+ * @since 13
+ */
+OH_PasteboardObserver* OH_PasteboardObserver_Create();
+
+/**
+ * @brief Destroy a {@link OH_PasteboardObserver} instance.
+ *
+ * @param observer Pointer to the {@link OH_PasteboardObserver} instance to destroy.
+ * @return Returns the status code of the execution. For details, see {@link PASTEBOARD_ErrCode}.
+ *         Returns {@link ERR_OK} if the operation is successful.
+ *         Returns {@link ERR_INVALID_PARAMETER} if invalid args are detected.
+ * @see OH_PasteboardObserver PASTEBOARD_ErrCode.
+ * @since 13
+ */
+int OH_PasteboardObserver_Destroy(OH_PasteboardObserver* observer);
+
+/**
+ * @brief Sets a callback function to return the Pasteboard data changed.
+ *
+ * @param observer Pointer to the {@link OH_PasteboardObserver} instance.
+ * @param context Pointer to the context set, which is the first parameter in Pasteboard_Notify.
+ * @param callback Callback to set. For details, see {@link Pasteboard_Notify}.
+ * @param finalize Optional callback that can free context when destroy observer.
+ *         For details, see {@link Pasteboard_Finalize}.
+ * @return Returns the status code of the execution. For details, see {@link PASTEBOARD_ErrCode}.
+ *         Returns {@link ERR_OK} if the operation is successful.
+ *         Returns {@link ERR_INVALID_PARAMETER} if invalid args are detected.
+ * @see OH_PasteboardObserver Pasteboard_Notify PASTEBOARD_ErrCode.
+ * @since 13
+ */
+int OH_PasteboardObserver_SetData(OH_PasteboardObserver* observer, void* context,
+    const Pasteboard_Notify callback, const Pasteboard_Finalize finalize);
+
+/**
+ * @brief Represents the Pasteboard information.
+ *
+ * @since 13
+ */
+typedef struct OH_Pasteboard OH_Pasteboard;
+
+/**
+ * @brief Creates a {@link OH_Pasteboard} instance.
+ *
+ * @return Returns the pointer to the {@link OH_Pasteboard} instance created if the operation is successful.
+ * Returns nullptr if the operation is failed.
+ * @see OH_Pasteboard.
+ * @since 13
+ */
+OH_Pasteboard* OH_Pasteboard_Create();
+
+/**
+ * @brief Destroy a {@link OH_Pasteboard} instance.
+ *
+ * @param pasteboard Pointer to the {@link OH_Pasteboard} instance to destroy.
+ * @see OH_Pasteboard.
+ * @since 13
+ */
+void OH_Pasteboard_Destroy(OH_Pasteboard* pasteboard);
+
+/**
+ * @brief Subscribes to the Pasteboard data change.
+ *
+ * @param pasteboard Pointer to the {@link OH_Pasteboard} instance.
+ * @param type Event type to subscribe to.
+ * @param observer - Pointer to the observer information, which specifies the callback used to
+ * reporting the pasteboard data change. For details, see {@link OH_PasteboardObserver}.
+ * @return Returns the status code of the execution. For details, {@link PASTEBOARD_ErrCode}.
+ *         Returns {@link ERR_OK} if the operation is successful.
+ *         Returns {@link ERR_INVALID_PARAMETER} if invalid args are detected.
+ * @see OH_Pasteboard OH_PasteboardObserver PASTEBOARD_ErrCode.
+ * @since 13
+ */
+int OH_Pasteboard_Subscribe(OH_Pasteboard* pasteboard, int type, const OH_PasteboardObserver* observer);
+
+/**
+ * @brief Unsubscribes from the Pasteboard data change.
+ *
+ * @param pasteboard Pointer to the {@link OH_Pasteboard} instance.
+ * @param type Event type to subscribe to.
+ * @param observer - Pointer to the observer information, which specifies the callback used to
+ * reporting the pasteboard data change. For details, see {@link OH_PasteboardObserver}.
+ * @return Returns the status code of the execution. For details, {@link PASTEBOARD_ErrCode}.
+ *         Returns {@link ERR_OK} if the operation is successful.
+ *         Returns {@link ERR_INVALID_PARAMETER} if invalid args are detected.
+ * @see OH_Pasteboard OH_PasteboardObserver PASTEBOARD_ErrCode.
+ * @since 13
+ */
+int OH_Pasteboard_Unsubscribe(OH_Pasteboard* pasteboard, int type, const OH_PasteboardObserver* observer);
+
+/**
+ * @brief Checks whether the Pasteboard data is from a remote device.
+ *
+ * @param pasteboard Pointer to the {@link OH_Pasteboard} instance.
+ * @return Returns a boolean value, which indicates whether the the data is from a remote device.
+ *         The value {@code false} means Pasteboard data is not from a remote device.
+ *         The value {@code true} means the opposite.
+ * @see OH_Pasteboard.
+ * @since 13
+ */
+bool OH_Pasteboard_IsRemoteData(OH_Pasteboard* pasteboard);
+
+/**
+ * @brief Obtains the source of Pasteboard data.
+ *
+ * @param pasteboard Pointer to the {@link OH_Pasteboard} instance.
+ * @param source Pointer to the source data.
+ * @param len Length of the source data.
+ * @return Returns the status code of the execution. For details, see {@link PASTEBOARD_ErrCode}.
+ *         Returns {@link ERR_OK} if the operation is successful.
+ *         Returns {@link ERR_INVALID_PARAMETER} if invalid args are detected.
+ * @see OH_Pasteboard PASTEBOARD_ErrCode.
+ * @since 13
+ */
+int OH_Pasteboard_GetDataSource(OH_Pasteboard* pasteboard, char* source, unsigned int len);
+
+/**
+ * @brief Checks whether the Pasteboard has the specified type of data.
+ *
+ * @param pasteboard Pointer to the {@link OH_Pasteboard} instance.
+ * @param type Poniter to the type of data to check.
+ * @return Returns a boolean value, which indicates whether the Pasteboard has the specified type of data.
+ *         The value {@code true} means the Pasteboard has the specified type of data.
+ *         The value {@code false} means the opposite.
+ * @see OH_Pasteboard.
+ * @since 13
+ */
+bool OH_Pasteboard_HasType(OH_Pasteboard* pasteboard, const char* type);
+
+/**
+ * @brief Checks whether there is data in the Pasteboard.
+ *
+ * @param pasteboard Pointer to the {@link OH_Pasteboard} instance.
+ * @return Returns a boolean value, which indicates whether there is data in the Pasteboard.
+ *         The value {@code true} means there is data in Pasteboard.
+ *         The value {@code false} means the opposite.
+ * @see OH_Pasteboard.
+ * @since 13
+ */
+bool OH_Pasteboard_HasData(OH_Pasteboard* pasteboard);
+
+/**
+ * @brief Obtains data from the Pasteboard.
+ *
+ * @param pasteboard Pointer to the {@link OH_Pasteboard} instance.
+ * @param status The status code of the execution. For details, see {@link PASTEBOARD_ErrCode}.
+ * @return Returns the pointer to the {@link OH_UdmfData} instance.
+ * @see OH_Pasteboard OH_UdmfData PASTEBOARD_ErrCode.
+ * @since 13
+ */
+OH_UdmfData* OH_Pasteboard_GetData(OH_Pasteboard* pasteboard, int* status);
+
+/**
+ * @brief Writes data to the Pasteboard.
+ *
+ * @param pasteboard Pointer to the {@link OH_Pasteboard} instance.
+ * @param data Pointer to the {@link OH_UdmfData} instance.
+ * @return Returns the status code of the execution. For details, see {@link PASTEBOARD_ErrCode}.
+ *         Returns {@link ERR_OK} if the operation is successful.
+ *         Returns {@link ERR_INVALID_PARAMETER} if invalid args are detected.
+ * @see OH_Pasteboard OH_UdmfData PASTEBOARD_ErrCode.
+ * @since 13
+ */
+int OH_Pasteboard_SetData(OH_Pasteboard* pasteboard, OH_UdmfData* data);
+
+/**
+ * @brief Clears the data in the Pastedboard.
+ *
+ * @param pasteboard Pointer to the {@link OH_Pasteboard} instance.
+ * @return Returns the status code of the execution. For details, see {@link PASTEBOARD_ErrCode}.
+ *         Returns {@link ERR_OK} if the operation is successful.
+ *         Returns {@link ERR_INVALID_PARAMETER} if invalid args are detected.
+ * @see OH_Pasteboard PASTEBOARD_ErrCode.
+ * @since 13
+ */
+int OH_Pasteboard_ClearData(OH_Pasteboard* pasteboard);
+#ifdef __cplusplus
+};
+#endif
+
+/** @} */
+#endif
\ No newline at end of file
diff --git a/interfaces/ndk/include/oh_pasteboard_common.h b/interfaces/ndk/include/oh_pasteboard_common.h
new file mode 100644
index 0000000000000000000000000000000000000000..cfa4436d7370c59c94bc8c38e02dd2867422be23
--- /dev/null
+++ b/interfaces/ndk/include/oh_pasteboard_common.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef OH_PASTEBOARD_COMMON_H
+#define OH_PASTEBOARD_COMMON_H
+#include <cstdint>
+#include <map>
+#include "pasteboard_observer.h"
+#include "oh_pasteboard.h"
+
+namespace OHOS {
+namespace MiscServices {
+class PasteboardObserverCapiImpl;
+}
+}
+
+enum PasteboardNdkStructId : std::int64_t {
+    SUBSCRIBER_STRUCT_ID = 1002950,
+    PASTEBOARD_STRUCT_ID,
+};
+
+struct OH_Pasteboard {
+    const int64_t cid = PASTEBOARD_STRUCT_ID;
+    std::mutex mutex;
+    std::map<const OH_PasteboardObserver*, OHOS::sptr<OHOS::MiscServices::PasteboardObserverCapiImpl>> observers_;
+};
+
+/** @} */
+#endif
\ No newline at end of file
diff --git a/interfaces/ndk/include/oh_pasteboard_err_code.h b/interfaces/ndk/include/oh_pasteboard_err_code.h
new file mode 100644
index 0000000000000000000000000000000000000000..772c29f1ed8d9930dced5e1e99a535a47070d803
--- /dev/null
+++ b/interfaces/ndk/include/oh_pasteboard_err_code.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @addtogroup Pasteboard
+ * @{
+ *
+ * @brief Provides the copy and paste support for the system Pasteboard.
+ * You can use the APIs of this module to operate the Pasteboard content of the plain text, HTML,
+ * URI, Want, pixel map, and other types.
+ *
+ * @since 12
+ */
+
+/**
+ * @file oh_pasteboard_err_code.h
+ *
+ * @brief Declaration error code information.
+ *
+ * @kit BasicServicesKit
+ * @library libpasteboard_ndk.so
+ * @syscap SystemCapability.MiscServices.Pasteboard
+ *
+ * @since 12
+ */
+
+
+#ifndef OH_PASTEBOARD_ERR_CODE_H
+#define OH_PASTEBOARD_ERR_CODE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Enumerates the error codes.
+ *
+ * @since 12
+ */
+typedef enum PASTEBOARD_ErrCode {
+    /**
+     * The operation is successful.
+     */
+    ERR_OK = 0,
+    /**
+     * Permission verification failed.
+     */
+    ERR_PERMISSION_ERROR = 201,
+    /**
+     * Invalid parameter is detected.
+     */
+    ERR_INVALID_PARAMETER = 401,
+    /**
+     * The capability is not supported.
+     */
+    ERR_DEVICE_NOT_SUPPORTED = 801,
+    ERR_ALLOCATE_MEMORY_FAIL,
+    ERR_OBSERVER_NOT_EXIST,
+    ERR_CLIENT_FAIL,
+    ERR_FAIL,
+} PASTEBOARD_ErrCode;
+
+#ifdef __cplusplus
+};
+#endif
+
+/** @} */
+#endif
diff --git a/interfaces/ndk/include/oh_pasteboard_observer_impl.h b/interfaces/ndk/include/oh_pasteboard_observer_impl.h
new file mode 100644
index 0000000000000000000000000000000000000000..8f105ec54eb0213de246f54dbeb7bb13132d7aba
--- /dev/null
+++ b/interfaces/ndk/include/oh_pasteboard_observer_impl.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef OH_PASTEBOARD_OBSERVER_IMPL_H
+#define OH_PASTEBOARD_OBSERVER_IMPL_H
+
+#include <memory>
+#include "pasteboard_observer.h"
+#include "oh_pasteboard_common.h"
+
+struct OH_PasteboardObserver {
+    const int64_t cid = SUBSCRIBER_STRUCT_ID;
+    Pasteboard_Notify callback { nullptr };
+    void* context { nullptr };
+    Pasteboard_Finalize finalize { nullptr };
+};
+
+namespace OHOS {
+namespace MiscServices {
+class PasteboardObserverCapiImpl : public PasteboardObserver {
+public:
+    void OnPasteboardChanged() override;
+    void SetType(Pasteboard_NotifyType type);
+    Pasteboard_NotifyType GetType();
+    void SetInnerObserver(const OH_PasteboardObserver* observer);
+private:
+    const OH_PasteboardObserver* innerObserver_;
+    Pasteboard_NotifyType type_;
+};
+}
+}
+
+/** @} */
+#endif
\ No newline at end of file
diff --git a/interfaces/ndk/src/oh_pasteboard.cpp b/interfaces/ndk/src/oh_pasteboard.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..80014ba2b1aaaa9fa003fec680467b4dc11a70cc
--- /dev/null
+++ b/interfaces/ndk/src/oh_pasteboard.cpp
@@ -0,0 +1,231 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "Pasteboard_Capi"
+
+#include "oh_pasteboard.h"
+#include <string>
+#include <memory>
+#include <thread>
+#include <map>
+#include "udmf.h"
+#include "oh_pasteboard_err_code.h"
+#include "oh_pasteboard_observer_impl.h"
+#include "pasteboard_client.h"
+#include "pasteboard_hilog.h"
+#include "pasteboard_error.h"
+#include "udmf_capi_common.h"
+#include "i_pasteboard_observer.h"
+
+using namespace OHOS::MiscServices;
+static bool IsPasteboardValid(OH_Pasteboard* pasteboard)
+{
+    return pasteboard != nullptr && pasteboard->cid == PASTEBOARD_STRUCT_ID;
+}
+
+static bool IsSubscriberValid(OH_PasteboardObserver* observer)
+{
+    return observer != nullptr && observer->cid == SUBSCRIBER_STRUCT_ID;
+}
+
+OH_PasteboardObserver* OH_PasteboardObserver_Create()
+{
+    OH_PasteboardObserver* observer = new(std::nothrow) OH_PasteboardObserver();
+    if (observer == nullptr) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CAPI, "allocate memory fail.");
+        return nullptr;
+    }
+    return observer;
+}
+
+int OH_PasteboardObserver_Destroy(OH_PasteboardObserver* observer)
+{
+    if (!IsSubscriberValid(observer)) {
+        return ERR_INVALID_PARAMETER;
+    }
+    if (observer->finalize != nullptr) {
+        (observer->finalize)(observer->context);
+        PASTEBOARD_HILOGD(PASTEBOARD_MODULE_CAPI, "context finalized");
+    }
+    delete observer;
+    return ERR_OK;
+}
+
+int OH_PasteboardObserver_SetData(OH_PasteboardObserver* observer, void* context,
+    const Pasteboard_Notify callback, const Pasteboard_Finalize finalize)
+{
+    if (observer == nullptr || callback == nullptr) {
+        return ERR_INVALID_PARAMETER;
+    }
+    observer->callback = callback;
+    if (context != nullptr && finalize == nullptr) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CAPI, "finalize is null");
+        return ERR_INVALID_PARAMETER;
+    }
+    observer->context = context;
+    observer->finalize = finalize;
+    return ERR_OK;
+}
+
+OH_Pasteboard* OH_Pasteboard_Create()
+{
+    OH_Pasteboard* pasteboard = new (std::nothrow) OH_Pasteboard();
+    if (pasteboard == nullptr) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CAPI, "allocate memory fail.");
+        return nullptr;
+    }
+    return pasteboard;
+}
+
+void OH_Pasteboard_Destroy(OH_Pasteboard* pasteboard)
+{
+    if (!IsPasteboardValid(pasteboard)) {
+        return;
+    }
+    std::lock_guard<std::mutex> lock(pasteboard->mutex);
+    for (auto iter : pasteboard->observers_) {
+        if (iter.second != nullptr) {
+            PasteboardClient::GetInstance()->Unsubscribe(
+                static_cast<PasteboardObserverType>(iter.second->GetType()), iter.second);
+        }
+    }
+    pasteboard->observers_.clear();
+    delete pasteboard;
+}
+
+int OH_Pasteboard_Subscribe(OH_Pasteboard* pasteboard, int type, const OH_PasteboardObserver* observer)
+{
+    if (!IsPasteboardValid(pasteboard) || observer == nullptr || type < NOTIFY_LOCAL_DATA_CHANGE
+        || type > NOTIFY_REMOTE_DATA_CHANGE) {
+        return ERR_INVALID_PARAMETER;
+    }
+    std::lock_guard<std::mutex> lock(pasteboard->mutex);
+    auto iter = pasteboard->observers_.find(observer);
+    if (iter != pasteboard->observers_.end()) {
+        PASTEBOARD_HILOGI(PASTEBOARD_MODULE_CAPI, "observer exist.");
+        return ERR_OK;
+    }
+    OHOS::sptr<PasteboardObserverCapiImpl> observerBox = new (std::nothrow) PasteboardObserverCapiImpl();
+    if (observerBox == nullptr) {
+        return ERR_ALLOCATE_MEMORY_FAIL;
+    }
+    observerBox->SetInnerObserver(observer);
+    observerBox->SetType(static_cast<Pasteboard_NotifyType>(type));
+    pasteboard->observers_[observer] = observerBox;
+    PasteboardClient::GetInstance()->Subscribe(static_cast<PasteboardObserverType>(type), observerBox);
+    return ERR_OK;
+}
+
+int OH_Pasteboard_Unsubscribe(OH_Pasteboard* pasteboard, int type, const OH_PasteboardObserver* observer)
+{
+    if (!IsPasteboardValid(pasteboard) || observer == nullptr  || type < NOTIFY_LOCAL_DATA_CHANGE
+        || type > NOTIFY_REMOTE_DATA_CHANGE) {
+        return ERR_INVALID_PARAMETER;
+    }
+    std::lock_guard<std::mutex> lock(pasteboard->mutex);
+    auto iter = pasteboard->observers_.find(observer);
+    if (iter == pasteboard->observers_.end()) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CAPI, "couldn't find this observer");
+        return ERR_OBSERVER_NOT_EXIST;
+    }
+    PasteboardClient::GetInstance()->Unsubscribe(static_cast<PasteboardObserverType>(type), iter->second);
+    pasteboard->observers_.erase(iter);
+    return ERR_OK;
+}
+
+bool OH_Pasteboard_IsRemoteData(OH_Pasteboard* pasteboard)
+{
+    if (!IsPasteboardValid(pasteboard)) {
+        return ERR_INVALID_PARAMETER;
+    }
+    return PasteboardClient::GetInstance()->IsRemoteData();
+}
+
+int OH_Pasteboard_GetDataSource(OH_Pasteboard* pasteboard, char* source, unsigned int len)
+{
+    if (!IsPasteboardValid(pasteboard) || source == nullptr || len == 0) {
+        return ERR_INVALID_PARAMETER;
+    }
+    std::string bundleName;
+    auto ret = PasteboardClient::GetInstance()->GetDataSource(bundleName);
+    if (ret != static_cast<int32_t>(PasteboardError::E_OK)) {
+        PASTEBOARD_HILOGE(
+            PASTEBOARD_MODULE_CAPI, "client getDataSource return invalid, result is %{public}d", ret);
+        return ERR_CLIENT_FAIL;
+    }
+    if (strcpy_s(source, len, bundleName.c_str()) != EOK) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CAPI, "copy string fail");
+        return ERR_FAIL;
+    }
+    return ERR_OK;
+}
+
+bool OH_Pasteboard_HasType(OH_Pasteboard* pasteboard, const char* type)
+{
+    if (!IsPasteboardValid(pasteboard) || type == nullptr) {
+        return ERR_INVALID_PARAMETER;
+    }
+    return PasteboardClient::GetInstance()->HasDataType(std::string(type));
+}
+
+bool OH_Pasteboard_HasData(OH_Pasteboard* pasteboard)
+{
+    if (!IsPasteboardValid(pasteboard)) {
+        return ERR_INVALID_PARAMETER;
+    }
+    return PasteboardClient::GetInstance()->HasPasteData();
+}
+
+OH_UdmfData* OH_Pasteboard_GetData(OH_Pasteboard* pasteboard, int* status)
+{
+    if (!IsPasteboardValid(pasteboard) || status == nullptr) {
+        return nullptr;
+    }
+    auto unifiedData = std::make_shared<OHOS::UDMF::UnifiedData>();
+    auto ret = PasteboardClient::GetInstance()->GetUdsdData(*unifiedData);
+    if (ret != static_cast<int32_t>(PasteboardError::E_OK)) {
+        PASTEBOARD_HILOGE(
+            PASTEBOARD_MODULE_CAPI, "client OH_Pasteboard_GetData return invalid, result is %{public}d", ret);
+        *status = ERR_CLIENT_FAIL;
+        return nullptr;
+    }
+    OH_UdmfData* data = OH_UdmfData_Create();
+    data->unifiedData_ = std::move(unifiedData);
+    *status = ERR_OK;
+    return data;
+}
+
+int OH_Pasteboard_SetData(OH_Pasteboard* pasteboard, OH_UdmfData* data)
+{
+    if (!IsPasteboardValid(pasteboard) || data == nullptr) {
+        return ERR_INVALID_PARAMETER;
+    }
+    auto ret = PasteboardClient::GetInstance()->SetUdsdData(*(data->unifiedData_));
+    if (ret != static_cast<int32_t>(PasteboardError::E_OK)) {
+        PASTEBOARD_HILOGE(
+            PASTEBOARD_MODULE_CAPI, "client OH_Pasteboard_SetData return invalid, result is %{public}d", ret);
+        return ERR_CLIENT_FAIL;
+    }
+    return ERR_OK;
+}
+
+int OH_Pasteboard_ClearData(OH_Pasteboard* pasteboard)
+{
+    if (!IsPasteboardValid(pasteboard)) {
+        return ERR_INVALID_PARAMETER;
+    }
+    PasteboardClient::GetInstance()->Clear();
+    return ERR_OK;
+}
\ No newline at end of file
diff --git a/interfaces/ndk/src/oh_pasteboard_observer_impl.cpp b/interfaces/ndk/src/oh_pasteboard_observer_impl.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..b9c9ae6df0c8faf169086d1eb6112c6057852497
--- /dev/null
+++ b/interfaces/ndk/src/oh_pasteboard_observer_impl.cpp
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "Pasteboard_Observer_Impl"
+
+#include "oh_pasteboard_observer_impl.h"
+#include "pasteboard_hilog.h"
+#include "oh_pasteboard_common.h"
+
+namespace OHOS {
+namespace MiscServices {
+void PasteboardObserverCapiImpl::OnPasteboardChanged()
+{
+    if (innerObserver_ == nullptr || innerObserver_->callback == nullptr) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CAPI, "subscriber is nullptr or subscriber callback is nullptr");
+        return;
+    }
+    (innerObserver_->callback)(innerObserver_->context, type_);
+}
+
+void PasteboardObserverCapiImpl::SetType(Pasteboard_NotifyType type)
+{
+    type_ = type;
+}
+
+Pasteboard_NotifyType PasteboardObserverCapiImpl::GetType()
+{
+    return type_;
+}
+
+void PasteboardObserverCapiImpl::SetInnerObserver(const OH_PasteboardObserver* innerObserver)
+{
+    innerObserver_ = innerObserver;
+}
+}
+}
\ No newline at end of file
diff --git a/interfaces/ndk/unittest/BUILD.gn b/interfaces/ndk/unittest/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..36937ae648df5c41cb38d7d8f63ef1564e9f3847
--- /dev/null
+++ b/interfaces/ndk/unittest/BUILD.gn
@@ -0,0 +1,63 @@
+# Copyright (c) 2024 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+import("//build/test.gni")
+import("//foundation/distributeddatamgr/pasteboard/pasteboard.gni")
+
+module_output_path = "distributeddatamgr/pasteboard"
+
+###############################################################################
+config("module_private_config") {
+  include_dirs = [
+    "${pasteboard_interfaces_path}/ndk/include",
+    "${pasteboard_framework_path}/innerkits/include",
+    "${pasteboard_interfaces_path}/kits/napi/include",
+    "${pasteboard_framework_path}/framework/include",
+  ]
+}
+
+common_deps = [
+  "${pasteboard_interfaces_path}/ndk:libpasteboard",
+  "${pasteboard_root_path}/framework/innerkits:pasteboard_client",
+]
+
+common_external_deps = [
+  "ability_base:want",
+  "access_token:libaccesstoken_sdk",
+  "access_token:libnativetoken",
+  "access_token:libtoken_setproc",
+  "c_utils:utils",
+  "hilog:libhilog",
+  "ipc:ipc_single",
+  "udmf:libudmf",
+  "os_account:os_account_innerkits",
+]
+
+ohos_unittest("PasteboardNdkTest") {
+  module_out_path = module_output_path
+
+  sources = [ "pasteboard_capi_test.cpp" ]
+
+  configs = [ ":module_private_config" ]
+
+  deps = common_deps
+
+  external_deps = common_external_deps
+}
+
+###############################################################################
+group("unittest") {
+  testonly = true
+
+  deps = [ ":PasteboardNdkTest" ]
+}
+###############################################################################
diff --git a/interfaces/ndk/unittest/pasteboard_capi_test.cpp b/interfaces/ndk/unittest/pasteboard_capi_test.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..a9ae53a66097ae9256b0560e47ec5be26136d3ff
--- /dev/null
+++ b/interfaces/ndk/unittest/pasteboard_capi_test.cpp
@@ -0,0 +1,561 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "PasteboardCapiTest"
+
+#include <gtest/gtest.h>
+#include <unistd.h>
+
+#include "token_setproc.h"
+#include "accesstoken_kit.h"
+#include "nativetoken_kit.h"
+
+#include "oh_pasteboard.h"
+#include "oh_pasteboard_err_code.h"
+#include "oh_pasteboard_observer_impl.h"
+#include "udmf.h"
+#include "uds.h"
+#include "pasteboard_hilog.h"
+#include "os_account_manager.h"
+
+using namespace testing::ext;
+using namespace OHOS::Security::AccessToken;
+using namespace OHOS::MiscServices;
+
+namespace OHOS::Test {
+class PasteboardCapiTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+    static void CallbackFunc(void* context, Pasteboard_NotifyType type);
+    static void RemoveCallbackSideEffects();
+    static void ContextFinalizeFunc(void* context);
+    static int callbackValue;
+    static void AllocTestTokenId();
+    static void DeleteTestTokenId();
+    static void SetTestTokenId();
+    static void RestoreSelfTokenId();
+    static void* GetDataCallback(void* context, const char* type);
+    static constexpr int INIT_VALUE = 0;
+    static constexpr int UPDATE_VALUE = 1;
+    static uint64_t selfTokenId_;
+    static AccessTokenID testTokenId_;
+    static constexpr char PLAINTEXT_CONTENT[] = "PLAINTEXT_CONTENT";
+    static constexpr char HYPERLINK_URL[] = "file://data/image.png";
+};
+uint64_t PasteboardCapiTest::selfTokenId_ = 0;
+AccessTokenID PasteboardCapiTest::testTokenId_ = 0;
+int PasteboardCapiTest::callbackValue = 0;
+
+void PasteboardCapiTest::SetUpTestCase(void)
+{
+    callbackValue = INIT_VALUE;
+    selfTokenId_ = GetSelfTokenID();
+    AllocTestTokenId();
+}
+
+void PasteboardCapiTest::TearDownTestCase(void)
+{
+    RemoveCallbackSideEffects();
+    DeleteTestTokenId();
+}
+
+void PasteboardCapiTest::SetUp(void)
+{
+}
+
+void PasteboardCapiTest::TearDown(void)
+{
+}
+
+void PasteboardCapiTest::AllocTestTokenId()
+{
+    std::vector<int32_t> ids;
+    auto ret = AccountSA::OsAccountManager::QueryActiveOsAccountIds(ids);
+    if (ret != ERR_OK || ids.empty()) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "query active user failed errCode = %{public}d", ret);
+        return;
+    }
+    HapInfoParams infoParams = {
+        .userID = ids[0],
+        .bundleName = "ohos.privacy_test.pasteboard",
+        .instIndex = 0,
+        .appIDDesc = "privacy_test.pasteboard"
+    };
+    PermissionStateFull testState = {
+        .permissionName = "ohos.permission.DUMP",
+        .isGeneral = true,
+        .resDeviceID = { "local" },
+        .grantStatus = { PermissionState::PERMISSION_GRANTED },
+        .grantFlags = { 1 }
+    };
+    HapPolicyParams policyParams = {
+        .apl = APL_NORMAL,
+        .domain = "test.domain.pasteboard",
+        .permList = {},
+        .permStateList = { testState }
+    };
+
+    AccessTokenKit::AllocHapToken(infoParams, policyParams);
+    testTokenId_ = Security::AccessToken::AccessTokenKit::GetHapTokenID(
+        infoParams.userID, infoParams.bundleName, infoParams.instIndex);
+    PASTEBOARD_HILOGD(PASTEBOARD_MODULE_SERVICE, "userID = %{public}d, testTokenId = 0x%{public}x.", infoParams.userID,
+        testTokenId_);
+}
+
+void PasteboardCapiTest::DeleteTestTokenId()
+{
+    AccessTokenKit::DeleteToken(testTokenId_);
+}
+
+
+void PasteboardCapiTest::SetTestTokenId()
+{
+    auto ret = SetSelfTokenID(testTokenId_);
+    PASTEBOARD_HILOGD(PASTEBOARD_MODULE_SERVICE, "testTokenId = 0x%{public}x, ret = %{public}d!", testTokenId_, ret);
+}
+
+void PasteboardCapiTest::RestoreSelfTokenId()
+{
+    auto ret = SetSelfTokenID(selfTokenId_);
+    PASTEBOARD_HILOGD(PASTEBOARD_MODULE_SERVICE, "ret = %{public}d!", ret);
+}
+
+void PasteboardCapiTest::CallbackFunc(void* context, Pasteboard_NotifyType type)
+{
+    callbackValue = UPDATE_VALUE;
+}
+
+void PasteboardCapiTest::RemoveCallbackSideEffects()
+{
+    callbackValue = INIT_VALUE;
+}
+
+void PasteboardCapiTest::ContextFinalizeFunc(void* context) {}
+
+void* PasteboardCapiTest::GetDataCallback(void* context, const char* type)
+{
+    if (std::string(type) == "general.plain-text") {
+        OH_UdsPlainText* plainText = OH_UdsPlainText_Create();
+        OH_UdsPlainText_SetContent(plainText, PLAINTEXT_CONTENT);
+        return plainText;
+    } else if (std::string(type) == "general.hyperlink") {
+        OH_UdsHyperlink* link = OH_UdsHyperlink_Create();
+        OH_UdsHyperlink_SetUrl(link, HYPERLINK_URL);
+        return link;
+    }
+    return nullptr;
+}
+
+/**
+ * @tc.name: OH_PasteboardSubscriber_Create001
+ * @tc.desc: OH_PasteboardObserver_Create test
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_PasteboardSubscriber_Create001, TestSize.Level1)
+{
+    OH_PasteboardObserver* observer = OH_PasteboardObserver_Create();
+    EXPECT_NE(observer, nullptr);
+
+    OH_PasteboardObserver_Destroy(observer);
+    OH_PasteboardObserver_Destroy(nullptr);
+}
+
+/**
+ * @tc.name: OH_PasteboardObserver_SetData001
+ * @tc.desc: OH_PasteboardObserver_SetData test valid
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_PasteboardObserver_SetData001, TestSize.Level1)
+{
+    OH_Pasteboard* pasteboard = OH_Pasteboard_Create();
+    void* context = static_cast<void*>(pasteboard);
+    OH_PasteboardObserver* observer = OH_PasteboardObserver_Create();
+
+    int setRes1 = OH_PasteboardObserver_SetData(observer, context, CallbackFunc, ContextFinalizeFunc);
+    EXPECT_EQ(setRes1, ERR_OK);
+
+    OH_PasteboardObserver_Destroy(observer);
+    OH_Pasteboard_Destroy(pasteboard);
+}
+
+/**
+ * @tc.name: OH_PasteboardObserver_SetData002
+ * @tc.desc: OH_PasteboardObserver_SetData test invalid
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_PasteboardObserver_SetData002, TestSize.Level1)
+{
+    OH_Pasteboard* pasteboard = OH_Pasteboard_Create();
+    void* context = static_cast<void*>(pasteboard);
+    OH_PasteboardObserver* observer = OH_PasteboardObserver_Create();
+
+    int setRes1 = OH_PasteboardObserver_SetData(nullptr, context, CallbackFunc, ContextFinalizeFunc);
+    EXPECT_EQ(setRes1, ERR_INVALID_PARAMETER);
+
+    int setRes2 = OH_PasteboardObserver_SetData(observer, context, nullptr, ContextFinalizeFunc);
+    EXPECT_EQ(setRes2, ERR_INVALID_PARAMETER);
+
+    int setRes3 = OH_PasteboardObserver_SetData(observer, context, CallbackFunc, nullptr);
+    EXPECT_EQ(setRes3, ERR_INVALID_PARAMETER);
+
+    OH_PasteboardObserver_Destroy(observer);
+    OH_Pasteboard_Destroy(pasteboard);
+}
+
+/**
+ * @tc.name: OH_Pasteboard_Create001
+ * @tc.desc: OH_Pasteboard_Create test valid
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_Pasteboard_Create001, TestSize.Level1)
+{
+    OH_Pasteboard* pasteboard = OH_Pasteboard_Create();
+    EXPECT_NE(pasteboard, nullptr);
+
+    OH_Pasteboard_Destroy(pasteboard);
+}
+
+/**
+ * @tc.name: OH_Pasteboard_Subscribe001
+ * @tc.desc: OH_Pasteboard_Subscribe test valid
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_Pasteboard_Subscribe001, TestSize.Level1)
+{
+    OH_Pasteboard* pasteboard = OH_Pasteboard_Create();
+    OH_PasteboardObserver* observer = OH_PasteboardObserver_Create();
+    OH_PasteboardObserver_SetData(observer, nullptr, CallbackFunc, ContextFinalizeFunc);
+
+    int res = OH_Pasteboard_Subscribe(pasteboard, NOTIFY_LOCAL_DATA_CHANGE, observer);
+    EXPECT_EQ(res, ERR_OK);
+
+    int resRepeat = OH_Pasteboard_Subscribe(pasteboard, NOTIFY_LOCAL_DATA_CHANGE, observer);
+    EXPECT_EQ(resRepeat, ERR_OK);
+
+    OH_Pasteboard_Destroy(pasteboard);
+    OH_PasteboardObserver_Destroy(observer);
+}
+
+/**
+ * @tc.name: OH_Pasteboard_Subscribe002
+ * @tc.desc: OH_Pasteboard_Subscribe test invalid
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_Pasteboard_Subscribe002, TestSize.Level1)
+{
+    OH_Pasteboard* pasteboard = OH_Pasteboard_Create();
+    OH_PasteboardObserver* observer = OH_PasteboardObserver_Create();
+    OH_PasteboardObserver_SetData(observer, nullptr, CallbackFunc, ContextFinalizeFunc);
+
+    int res1 = OH_Pasteboard_Subscribe(nullptr, NOTIFY_LOCAL_DATA_CHANGE, observer);
+    EXPECT_EQ(res1, ERR_INVALID_PARAMETER);
+
+    int res2 = OH_Pasteboard_Subscribe(pasteboard, 10, observer);
+    EXPECT_EQ(res2, ERR_INVALID_PARAMETER);
+
+    int res3 = OH_Pasteboard_Subscribe(pasteboard, -1, observer);
+    EXPECT_EQ(res3, ERR_INVALID_PARAMETER);
+
+    int res4 = OH_Pasteboard_Subscribe(pasteboard, NOTIFY_LOCAL_DATA_CHANGE, nullptr);
+    EXPECT_EQ(res4, ERR_INVALID_PARAMETER);
+
+    OH_Pasteboard_Destroy(pasteboard);
+    OH_PasteboardObserver_Destroy(observer);
+}
+
+/**
+ * @tc.name: OH_Pasteboard_Unsubcribe001
+ * @tc.desc: OH_Pasteboard_Unsubcribe test valid
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_Pasteboard_Unsubcribe001, TestSize.Level1)
+{
+    OH_Pasteboard* pasteboard = OH_Pasteboard_Create();
+    OH_PasteboardObserver* observer = OH_PasteboardObserver_Create();
+    OH_PasteboardObserver_SetData(observer, nullptr, CallbackFunc, ContextFinalizeFunc);
+
+    OH_Pasteboard_Subscribe(pasteboard, NOTIFY_LOCAL_DATA_CHANGE, observer);
+
+    int res = OH_Pasteboard_Unsubscribe(pasteboard, NOTIFY_LOCAL_DATA_CHANGE, observer);
+    EXPECT_EQ(res, ERR_OK);
+
+    OH_Pasteboard_Destroy(pasteboard);
+    OH_PasteboardObserver_Destroy(observer);
+}
+
+/**
+ * @tc.name: OH_Pasteboard_Unsubscribe002
+ * @tc.desc: OH_Pasteboard_Unsubscribe test invalid
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_Pasteboard_Unsubcribe002, TestSize.Level1)
+{
+    OH_Pasteboard* pasteboard = OH_Pasteboard_Create();
+    OH_PasteboardObserver* observer = OH_PasteboardObserver_Create();
+    OH_PasteboardObserver_SetData(observer, nullptr, CallbackFunc, ContextFinalizeFunc);
+
+    int res1 = OH_Pasteboard_Unsubscribe(nullptr, NOTIFY_LOCAL_DATA_CHANGE, observer);
+    EXPECT_EQ(res1, ERR_INVALID_PARAMETER);
+
+    int res2 = OH_Pasteboard_Unsubscribe(pasteboard, 10, observer);
+    EXPECT_EQ(res2, ERR_INVALID_PARAMETER);
+
+    int res3 = OH_Pasteboard_Unsubscribe(pasteboard, -1, observer);
+    EXPECT_EQ(res3, ERR_INVALID_PARAMETER);
+
+    int res4 = OH_Pasteboard_Unsubscribe(pasteboard, NOTIFY_LOCAL_DATA_CHANGE, nullptr);
+    EXPECT_EQ(res4, ERR_INVALID_PARAMETER);
+
+    OH_Pasteboard_Destroy(pasteboard);
+    OH_PasteboardObserver_Destroy(observer);
+}
+
+/**
+ * @tc.name: OH_Pasteboard_IsRemoteData001
+ * @tc.desc: OH_Pasteboard_IsRemoteData test valid
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_Pasteboard_IsRemoteData001, TestSize.Level1)
+{
+    OH_Pasteboard* pasteboard = OH_Pasteboard_Create();
+
+    bool res = OH_Pasteboard_IsRemoteData(pasteboard);
+    EXPECT_FALSE(res);
+
+    OH_Pasteboard_Destroy(pasteboard);
+}
+
+/**
+ * @tc.name: OH_Pasteboard_GetDataSrouce001
+ * @tc.desc: OH_Pasteboard_GetDataSrouce test valid
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_Pasteboard_GetDataSrouce001, TestSize.Level1)
+{
+    OH_Pasteboard* pasteboard = OH_Pasteboard_Create();
+    OH_UdmfData* setData = OH_UdmfData_Create();
+    OH_UdmfRecord* record = OH_UdmfRecord_Create();
+    OH_UdsPlainText* plainText = OH_UdsPlainText_Create();
+    char content[] = "hello world";
+    OH_UdsPlainText_SetContent(plainText, content);
+    OH_UdmfRecord_AddPlainText(record, plainText);
+    OH_UdmfData_AddRecord(setData, record);
+
+    OH_Pasteboard_SetData(pasteboard, setData);
+
+    int len = 100;
+    char source[100];
+    int res = OH_Pasteboard_GetDataSource(pasteboard, source, len);
+    EXPECT_EQ(res, ERR_OK);
+    
+    OH_Pasteboard_Destroy(pasteboard);
+}
+
+/**
+ * @tc.name: OH_Pasteboard_HasType001
+ * @tc.desc: OH_Pasteboard_HasType test valid
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_Pasteboard_HasType001, TestSize.Level1)
+{
+    OH_Pasteboard* pasteboard = OH_Pasteboard_Create();
+    OH_UdmfData* setData = OH_UdmfData_Create();
+    OH_UdmfRecord* record = OH_UdmfRecord_Create();
+    OH_UdsPlainText* plainText = OH_UdsPlainText_Create();
+    char content[] = "hello world";
+    OH_UdsPlainText_SetContent(plainText, content);
+    OH_UdmfRecord_AddPlainText(record, plainText);
+    OH_UdmfData_AddRecord(setData, record);
+
+    OH_Pasteboard_SetData(pasteboard, setData);
+    char type[] = "general.plain-text";
+    bool res = OH_Pasteboard_HasType(pasteboard, type);
+    EXPECT_FALSE(res);
+    
+    OH_Pasteboard_Destroy(pasteboard);
+}
+
+/**
+ * @tc.name: OH_Pasteboard_HasData001
+ * @tc.desc: OH_Pasteboard_HasData test valid
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_Pasteboard_HasData001, TestSize.Level1)
+{
+    OH_Pasteboard* pasteboard = OH_Pasteboard_Create();
+    OH_Pasteboard_ClearData(pasteboard);
+    bool res = OH_Pasteboard_HasData(pasteboard);
+    EXPECT_FALSE(res);
+
+    OH_UdmfData* setData = OH_UdmfData_Create();
+    OH_UdmfRecord* record = OH_UdmfRecord_Create();
+    OH_UdsPlainText* plainText = OH_UdsPlainText_Create();
+    char content[] = "hello world";
+    OH_UdsPlainText_SetContent(plainText, content);
+    OH_UdmfRecord_AddPlainText(record, plainText);
+    OH_UdmfData_AddRecord(setData, record);
+
+    OH_Pasteboard_SetData(pasteboard, setData);
+
+    res = OH_Pasteboard_HasData(pasteboard);
+    EXPECT_TRUE(res);
+    
+    OH_Pasteboard_Destroy(pasteboard);
+}
+
+/**
+ * @tc.name: OH_Pasteboard_ClearData001
+ * @tc.desc: OH_Pasteboard_ClearData test valid
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_Pasteboard_ClearData001, TestSize.Level1)
+{
+    OH_Pasteboard* pasteboard = OH_Pasteboard_Create();
+    bool res = OH_Pasteboard_ClearData(pasteboard);
+    EXPECT_EQ(res, ERR_OK);
+    
+    OH_Pasteboard_Destroy(pasteboard);
+}
+
+/**
+ * @tc.name: OH_Pasteboard_SetData001
+ * @tc.desc: OH_Pasteboard_SetData test valid
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_Pasteboard_SetData001, TestSize.Level1)
+{
+    OH_Pasteboard* pasteboard = OH_Pasteboard_Create();
+    OH_UdmfData *setData = OH_UdmfData_Create();
+    OH_UdmfRecord *record = OH_UdmfRecord_Create();
+    OH_UdsPlainText *plainText = OH_UdsPlainText_Create();
+    char content[] = "hello world";
+    OH_UdsPlainText_SetContent(plainText, content);
+    OH_UdmfRecord_AddPlainText(record, plainText);
+    OH_UdmfData_AddRecord(setData, record);
+
+    bool res = OH_Pasteboard_SetData(pasteboard, setData);
+    EXPECT_EQ(res, ERR_OK);
+    
+    OH_Pasteboard_Destroy(pasteboard);
+    OH_UdsPlainText_Destroy(plainText);
+    OH_UdmfRecord_Destroy(record);
+    OH_UdmfData_Destroy(setData);
+}
+
+/**
+ * @tc.name: OH_Pasteboard_GetData001
+ * @tc.desc: OH_Pasteboard_GetData test valid
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_Pasteboard_GetData001, TestSize.Level1)
+{
+    OH_Pasteboard* pasteboard = OH_Pasteboard_Create();
+    OH_UdmfData* setData = OH_UdmfData_Create();
+    OH_UdmfRecord* record = OH_UdmfRecord_Create();
+    OH_UdsPlainText* plainText = OH_UdsPlainText_Create();
+    char content[] = "hello world";
+    OH_UdsPlainText_SetContent(plainText, content);
+    OH_UdmfRecord_AddPlainText(record, plainText);
+    OH_UdmfData_AddRecord(setData, record);
+
+    int res = OH_Pasteboard_SetData(pasteboard, setData);
+    EXPECT_EQ(res, ERR_OK);
+
+    int status = -1;
+    OH_UdmfData* getData = OH_Pasteboard_GetData(pasteboard, &status);
+    EXPECT_EQ(status, ERR_OK);
+    EXPECT_NE(getData, nullptr);
+
+    unsigned int count = 0;
+    OH_UdmfRecord **getRecords = OH_UdmfData_GetRecords(getData, &count);
+    EXPECT_EQ(count, 1);
+    OH_UdsPlainText *getPlainText = OH_UdsPlainText_Create();
+    OH_UdmfRecord_GetPlainText(getRecords[0], getPlainText);
+    const char *getContent = OH_UdsPlainText_GetContent(getPlainText);
+    PASTEBOARD_HILOGI(PASTEBOARD_MODULE_SERVICE, "content is %{public}s", getContent);
+    EXPECT_EQ(strcmp(getContent, content), 0);
+
+    OH_Pasteboard_Destroy(pasteboard);
+    OH_UdsPlainText_Destroy(plainText);
+    OH_UdsPlainText_Destroy(getPlainText);
+    OH_UdmfRecord_Destroy(record);
+    OH_UdmfData_Destroy(setData);
+    OH_UdmfData_Destroy(getData);
+}
+
+/**
+ * @tc.name: OH_Pasteboard_GetData002
+ * @tc.desc: OH_Pasteboard_GetData test valid
+ * @tc.type: FUNC
+ * @tc.require: AROOOH5R5G
+ */
+HWTEST_F(PasteboardCapiTest, OH_Pasteboard_GetData002, TestSize.Level1)
+{
+    OH_Pasteboard* pasteboard = OH_Pasteboard_Create();
+    OH_UdmfData* setData = OH_UdmfData_Create();
+    OH_UdmfRecord* record = OH_UdmfRecord_Create();
+    OH_UdmfRecordProvider* provider = OH_UdmfRecordProvider_Create();
+    EXPECT_NE(provider, nullptr);
+    OH_UdmfRecordProvider_SetData(provider, static_cast<void *>(record), GetDataCallback, ContextFinalizeFunc);
+    OH_UdmfData_AddRecord(setData, record);
+
+    const char* types[3] = { "general.plain-text", "general.hyperlink", "general.html" };
+    OH_UdmfRecord_SetProvider(record, types, 3, provider);
+    int res = OH_Pasteboard_SetData(pasteboard, setData);
+    EXPECT_EQ(res, ERR_OK);
+
+    int status = -1;
+    OH_UdmfData* getData = OH_Pasteboard_GetData(pasteboard, &status);
+    EXPECT_EQ(status, ERR_OK);
+    EXPECT_NE(getData, nullptr);
+
+    unsigned int count = 0;
+    OH_UdmfRecord **getRecords = OH_UdmfData_GetRecords(getData, &count);
+    EXPECT_EQ(count, 1);
+    OH_UdsPlainText *getPlainText = OH_UdsPlainText_Create();
+    OH_UdmfRecord_GetPlainText(getRecords[0], getPlainText);
+    const char *getContent = OH_UdsPlainText_GetContent(getPlainText);
+    EXPECT_EQ(strcmp(getContent, PLAINTEXT_CONTENT), 0);
+
+    OH_UdsHyperlink *getHyperLink = OH_UdsHyperlink_Create();
+    OH_UdmfRecord_GetHyperlink(getRecords[0], getHyperLink);
+    const char *getUrl = OH_UdsHyperlink_GetUrl(getHyperLink);
+    EXPECT_EQ(strcmp(getUrl, HYPERLINK_URL), 0);
+    OH_Pasteboard_Destroy(pasteboard);
+    OH_UdsPlainText_Destroy(getPlainText);
+    OH_UdsHyperlink_Destroy(getHyperLink);
+    OH_UdmfRecord_Destroy(record);
+    OH_UdmfData_Destroy(setData);
+    OH_UdmfData_Destroy(getData);
+}
+}
\ No newline at end of file
diff --git a/services/BUILD.gn b/services/BUILD.gn
index 293506cfad1ee77c99415163ca156bea403c8613..5d65b04ebb5c14b7aad322d06fa63fd40383a397 100644
--- a/services/BUILD.gn
+++ b/services/BUILD.gn
@@ -57,8 +57,6 @@ ohos_shared_library("pasteboard_service") {
     debug = false
   }
   sources = [
-    "${pasteboard_innerkits_path}/src/paste_data.cpp",
-    "${pasteboard_innerkits_path}/src/paste_data_record.cpp",
     "../adapter/data_share/datashare_delegate.cpp",
     "../adapter/security_level/security_level.cpp",
     "account/src/account_manager.cpp",
@@ -80,6 +78,7 @@ ohos_shared_library("pasteboard_service") {
     "switch/pasteboard_switch.cpp",
     "zidl/src/ipasteboard_client_death_observer.cpp",
     "zidl/src/pasteboard_delay_getter_proxy.cpp",
+    "zidl/src/pasteboard_entry_getter_proxy.cpp",
     "zidl/src/pasteboard_observer_proxy.cpp",
     "zidl/src/pasteboard_service_stub.cpp",
   ]
@@ -97,6 +96,7 @@ ohos_shared_library("pasteboard_service") {
   deps = [
     "${pasteboard_framework_path}:pasteboard_framework",
     "//foundation/distributeddatamgr/pasteboard/framework/framework:pasteboard_framework",
+    "//foundation/distributeddatamgr/pasteboard/framework/innerkits:pasteboard_client",
     "//foundation/distributeddatamgr/pasteboard/framework/tlv:pasteboard_tlv",
     "//foundation/distributeddatamgr/pasteboard/framework/uri:pasteboard_uri",
   ]
diff --git a/services/core/include/i_pasteboard_entry_getter.h b/services/core/include/i_pasteboard_entry_getter.h
new file mode 100644
index 0000000000000000000000000000000000000000..4ce524ae800ad07bb0c0a516e69754d7b70ab61b
--- /dev/null
+++ b/services/core/include/i_pasteboard_entry_getter.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef I_PASTEBOARD_ENTRY_GETTER_H
+#define I_PASTEBOARD_ENTRY_GETTER_H
+
+#include "iremote_broker.h"
+#include "paste_data_entry.h"
+
+namespace OHOS {
+namespace MiscServices {
+class IPasteboardEntryGetter : public IRemoteBroker {
+public:
+    virtual ~IPasteboardEntryGetter() = default;
+    virtual int32_t GetRecordValueByType(uint32_t recordId, PasteDataEntry& value) = 0;
+    DECLARE_INTERFACE_DESCRIPTOR(u"ohos.misc.services.pasteboard.IPasteboardEntryGetter");
+};
+} // namespace MiscServices
+} // namespace OHOS
+#endif // I_PASTEBOARD_ENTRY_GETTER_H
\ No newline at end of file
diff --git a/services/core/include/i_pasteboard_service.h b/services/core/include/i_pasteboard_service.h
index 696b7d2c9e0303c9672bd7133790690ec4ce7ab9..ee0e6cd65e8d05641ac06995ac66e49bbc713393 100644
--- a/services/core/include/i_pasteboard_service.h
+++ b/services/core/include/i_pasteboard_service.h
@@ -16,6 +16,7 @@
 #ifndef PASTE_BOARD_SERVICE_INTERFACE_H
 #define PASTE_BOARD_SERVICE_INTERFACE_H
 
+#include "i_pasteboard_entry_getter.h"
 #include "i_pasteboard_delay_getter.h"
 #include "i_pasteboard_observer.h"
 #include "iremote_broker.h"
@@ -27,9 +28,11 @@ namespace MiscServices {
 class IPasteboardService : public IRemoteBroker {
 public:
     virtual void Clear() = 0;
+    virtual int32_t GetRecordValueByType(uint32_t dataId, uint32_t recordId, PasteDataEntry &value) = 0;
     virtual int32_t GetPasteData(PasteData &data, int32_t &syncTime) = 0;
     virtual bool HasPasteData() = 0;
-    virtual int32_t SetPasteData(PasteData &pasteData, const sptr<IPasteboardDelayGetter> delayGetter) = 0;
+    virtual int32_t SetPasteData(PasteData &pasteData, const sptr<IPasteboardDelayGetter> delayGetter,
+        const sptr<IPasteboardEntryGetter> entryGetter) = 0;
     virtual bool IsRemoteData() = 0;
     virtual int32_t GetDataSource(std::string &bundleName) = 0;
     virtual bool HasDataType(const std::string &mimeType) = 0;
diff --git a/services/core/include/pasteboard_serv_ipc_interface_code.h b/services/core/include/pasteboard_serv_ipc_interface_code.h
index 8517d380c97b86079ed5a4eceedb115b9602214f..d63d060e4fe5c2aecee97b1ac4ba102b6d2649da 100644
--- a/services/core/include/pasteboard_serv_ipc_interface_code.h
+++ b/services/core/include/pasteboard_serv_ipc_interface_code.h
@@ -40,12 +40,17 @@ enum PasteboardServiceInterfaceCode {
     PASTE_COMPLETE = 16,
     REGISTER_CLIENT_DEATH_OBSERVER = 17,
     DETECT_PATTERNS = 18,
+    GET_RECORD_VALUE = 19,
 };
 
 enum PasteboardObserverInterfaceCode {
     ON_PASTE_BOARD_CHANGE = 0,
     ON_PASTE_BOARD_EVENT = 1,
 };
+
+enum PasteboardEntryGetterInterfaceCode {
+    GET_RECORD_VALUE_BY_TYPE = 0,
+};
 } // namespace PasteboardServ
 } // namespace Security
 } // namespace OHOS
diff --git a/services/core/include/pasteboard_service.h b/services/core/include/pasteboard_service.h
index 4cb7a9351f0f368e0cae6182f8450e2542b32042..3758cbef7c9f15a2a1fc93a45499a12535ac15dd 100644
--- a/services/core/include/pasteboard_service.h
+++ b/services/core/include/pasteboard_service.h
@@ -96,9 +96,11 @@ public:
     API_EXPORT PasteboardService();
     API_EXPORT ~PasteboardService();
     virtual void Clear() override;
+    virtual int32_t GetRecordValueByType(uint32_t dataId, uint32_t recordId, PasteDataEntry &value) override;
     virtual int32_t GetPasteData(PasteData &data, int32_t &syncTime) override;
     virtual bool HasPasteData() override;
-    virtual int32_t SetPasteData(PasteData &pasteData, const sptr<IPasteboardDelayGetter> delayGetter) override;
+    virtual int32_t SetPasteData(PasteData &pasteData, const sptr<IPasteboardDelayGetter> delayGetter,
+        const sptr<IPasteboardEntryGetter> entryGetter) override;
     virtual bool IsRemoteData() override;
     virtual bool HasDataType(const std::string &mimeType) override;
     virtual std::set<Pattern> DetectPatterns(const std::set<Pattern> &patternsToCheck) override;
@@ -124,6 +126,7 @@ public:
     bool SetPasteboardHistory(HistoryInfo &info);
     int Dump(int fd, const std::vector<std::u16string> &args) override;
     void NotifyDelayGetterDied(int32_t userId);
+    void NotifyEntryGetterDied(int32_t userId);
     bool IsFocusedApp(uint32_t tokenId);
 
 private:
@@ -154,6 +157,16 @@ private:
         PasteboardService &service_;
     };
 
+    class EntryGetterDeathRecipient final : public IRemoteObject::DeathRecipient {
+    public:
+        explicit EntryGetterDeathRecipient(int32_t userId, PasteboardService &service);
+        virtual ~EntryGetterDeathRecipient() = default;
+        void OnRemoteDied(const wptr<IRemoteObject>& remote) override;
+    private:
+        int32_t userId_ = ERROR_USERID;
+        PasteboardService &service_;
+    };
+
     class RemoteDataTaskManager {
     public:
         struct TaskContext {
@@ -191,7 +204,8 @@ private:
     bool IsCopyable(uint32_t tokenId) const;
 
     int32_t SavePasteData(std::shared_ptr<PasteData> &pasteData,
-        sptr<IPasteboardDelayGetter> delayGetter = nullptr) override;
+        sptr<IPasteboardDelayGetter> delayGetter = nullptr,
+        sptr<IPasteboardEntryGetter> entryGetter = nullptr) override;
     void RemovePasteData(const AppInfo &appInfo);
     void SetPasteDataDot(PasteData &pasteData);
     std::pair<bool, ClipPlugin::GlobalEvent> GetValidDistributeEvent(int32_t user);
@@ -203,7 +217,7 @@ private:
     int32_t GetLocalData(const AppInfo &appInfo, PasteData &data);
     int32_t GetRemoteData(int32_t userId, const Event &event, PasteData &data, int32_t &syncTime);
     int32_t GetRemotePasteData(int32_t userId, const Event &event, PasteData &data, int32_t &syncTime);
-    int64_t GetFileSize(PasteData &data);
+    bool GetDelayPasteRecord(const AppInfo &appInfo, PasteData &data);
     void GetDelayPasteData(const AppInfo &appInfo, PasteData &data);
     void CheckUriPermission(PasteData &data, std::vector<Uri> &grantUris, const std::string &targetBundleName);
     int32_t GrantUriPermission(PasteData &data, const std::string &targetBundleName);
@@ -219,6 +233,7 @@ private:
     bool HasDistributedDataType(const std::string &mimeType);
 
     std::pair<std::shared_ptr<PasteData>, int32_t> GetDistributedData(const Event &event, int32_t user);
+    void GetFullDelayPasteData(int32_t userId, PasteData &data);
     bool SetDistributedData(int32_t user, PasteData &data);
     bool CleanDistributedData(int32_t user);
     void OnConfigChange(bool isOn);
@@ -248,6 +263,7 @@ private:
     ClipPlugin::GlobalEvent remoteEvent_;
     const std::string filePath_ = "";
     ConcurrentMap<int32_t, std::shared_ptr<PasteData>> clips_;
+    ConcurrentMap<int32_t, std::pair<sptr<IPasteboardEntryGetter>, sptr<EntryGetterDeathRecipient>>> entryGetters_;
     ConcurrentMap<int32_t, std::pair<sptr<IPasteboardDelayGetter>, sptr<DelayGetterDeathRecipient>>> delayGetters_;
     ConcurrentMap<int32_t, uint64_t> copyTime_;
     std::set<std::string> readBundles_;
@@ -256,6 +272,7 @@ private:
     std::recursive_mutex mutex;
     std::shared_ptr<ClipPlugin> clipPlugin_ = nullptr;
     std::atomic<uint16_t> sequenceId_ = 0;
+    std::atomic<uint32_t> dataId_ = 0;
     static std::mutex historyMutex_;
     std::mutex bundleMutex_;
     static std::vector<std::string> dataHistory_;
diff --git a/services/core/src/pasteboard_service.cpp b/services/core/src/pasteboard_service.cpp
index 08ecac766fc362b881d3c77f20f6305344558e0b..6b9b2999a143979b3f37e5760fad7683893b77bd 100644
--- a/services/core/src/pasteboard_service.cpp
+++ b/services/core/src/pasteboard_service.cpp
@@ -246,6 +246,27 @@ void PasteboardService::NotifyDelayGetterDied(int32_t userId)
     delayGetters_.Erase(userId);
 }
 
+PasteboardService::EntryGetterDeathRecipient::EntryGetterDeathRecipient(int32_t userId, PasteboardService &service)
+    : userId_(userId), service_(service)
+{
+    PASTEBOARD_HILOGI(PASTEBOARD_MODULE_SERVICE, "Construct Entry Getter Death Recipient");
+}
+
+void PasteboardService::EntryGetterDeathRecipient::OnRemoteDied(const wptr<IRemoteObject>& remote)
+{
+    PASTEBOARD_HILOGI(PASTEBOARD_MODULE_SERVICE, "start");
+    (void) remote;
+    service_.NotifyEntryGetterDied(userId_);
+}
+
+void PasteboardService::NotifyEntryGetterDied(int32_t userId)
+{
+    if (userId == ERROR_USERID) {
+        return;
+    }
+    entryGetters_.Erase(userId);
+}
+
 void PasteboardService::DMAdapterInit()
 {
     auto appInfo = GetAppInfo(IPCSkeleton::GetCallingTokenID());
@@ -290,6 +311,57 @@ void PasteboardService::Clear()
     CleanDistributedData(userId);
 }
 
+int32_t PasteboardService::GetRecordValueByType(uint32_t dataId, uint32_t recordId, PasteDataEntry& value)
+{
+    auto tokenId = IPCSkeleton::GetCallingTokenID();
+    auto callPid = IPCSkeleton::GetCallingPid();
+    if (!VerifyPermission(tokenId)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "check permission failed, calling pid is %{public}d", callPid);
+        return static_cast<int32_t>(PasteboardError::E_NO_PERMISSION);
+    }
+    auto appInfo = GetAppInfo(tokenId);
+    auto clip = clips_.Find(appInfo.userId);
+    auto tempTime = copyTime_.Find(appInfo.userId);
+    auto entryGetter = entryGetters_.Find(appInfo.userId);
+    if (!clip.first || !tempTime.first || !entryGetter.first) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "pasteboard has no data or entry getter");
+        return static_cast<int32_t>(PasteboardError::E_ERROR);
+    }
+    auto data = clip.second;
+    if (dataId != data->GetDataId()) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE,
+            "get record value fail, data is out time, pre dataId is %{public}d, cur dataId is %{public}d",
+            dataId, data->GetDataId());
+        return static_cast<int32_t>(PasteboardError::E_ERROR);
+    }
+    auto getter = entryGetter.second;
+    if (getter.first == nullptr) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE,
+            "entry getter is nullptr, dataId is %{public}d, recordId is %{public}d", dataId, recordId);
+        return static_cast<int32_t>(PasteboardError::E_ERROR);
+    }
+    auto result = getter.first->GetRecordValueByType(recordId, value);
+    if (result != static_cast<int32_t>(PasteboardError::E_OK)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE,
+            "get record value fail, dataId is %{public}d, recordId is %{public}d", dataId, recordId);
+        return result;
+    }
+    clips_.ComputeIfPresent(appInfo.userId, [dataId, recordId, value](auto, auto &data) {
+        if (dataId != data->GetDataId()) {
+            PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE,
+                "set record value fail, data is out time, pre dataId is %{public}d, cur dataId is %{public}d",
+                dataId, data->GetDataId());
+            return true;
+        }
+        auto record = data->GetRecordAt(recordId - 1);
+        if (record != nullptr) {
+            record->AddEntry(value.GetUtdId(), std::make_shared<PasteDataEntry>(value));
+        }
+        return true;
+    });
+    return static_cast<int32_t>(PasteboardError::E_OK);
+}
+
 bool PasteboardService::IsDefaultIME(const AppInfo &appInfo)
 {
     if (appInfo.tokenType != ATokenTypeEnum::TOKEN_HAP) {
@@ -727,6 +799,10 @@ int32_t PasteboardService::GetLocalData(const AppInfo &appInfo, PasteData &data)
         GetDelayPasteData(appInfo, data);
         RADAR_REPORT(DFX_GET_PASTEBOARD, DFX_CHECK_GET_DELAY_PASTE, DFX_SUCCESS, CONCURRENT_ID, pasteId);
     }
+    bool isDelayRecordPadding = false;
+    if (it.second->IsDelayRecord()) {
+        isDelayRecordPadding = GetDelayPasteRecord(appInfo, data);
+    }
     data.SetBundleName(appInfo.bundleName);
     auto result = copyTime_.Find(appInfo.userId);
     if (!result.first) {
@@ -736,8 +812,8 @@ int32_t PasteboardService::GetLocalData(const AppInfo &appInfo, PasteData &data)
     auto curTime = result.second;
     if (tempTime.second == curTime) {
         bool isNotify = false;
-        clips_.ComputeIfPresent(appInfo.userId, [&data, &isNotify](auto &key, auto &value) {
-            if (value->IsDelayData()) {
+        clips_.ComputeIfPresent(appInfo.userId, [&data, &isNotify, &isDelayRecordPadding](auto &key, auto &value) {
+            if (value->IsDelayData() || (value->IsDelayRecord() && isDelayRecordPadding)) {
                 value = std::make_shared<PasteData>(data);
                 isNotify = true;
             }
@@ -775,6 +851,42 @@ void PasteboardService::GetDelayPasteData(const AppInfo &appInfo, PasteData &dat
     });
 }
 
+bool PasteboardService::GetDelayPasteRecord(const AppInfo &appInfo, PasteData &data)
+{
+    auto entryGetter = entryGetters_.Find(appInfo.userId);
+    if (!entryGetter.first) {
+        return false;
+    }
+    auto getter = entryGetter.second;
+    if (getter.first == nullptr) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "entry getter is nullptr, dataId is %{public}d", data.GetDataId());
+        return false;
+    }
+    bool isPadding = false;
+    for (auto record : data.AllRecords()) {
+        if (!(record->IsEmpty())) {
+            continue;
+        }
+        if (!record->IsDelayRecord()) {
+            continue;
+        }
+        auto entries = record->GetEntries();
+        if (entries.size() <= 0) {
+            continue;
+        }
+        auto result = getter.first->GetRecordValueByType(record->GetRecordId(), *entries[0]);
+        if (result != static_cast<int32_t>(PasteboardError::E_OK)) {
+            PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE,
+                "get record value fail, dataId is %{public}d, recordId is %{public}d",
+                data.GetDataId(), record->GetRecordId());
+            continue;
+        }
+        record->AddEntry(entries[0]->GetUtdId(), entries[0]);
+        isPadding = true;
+    }
+    return isPadding;
+}
+
 void PasteboardService::EstablishP2PLink(const std::string &networkId, const std::string &pasteId)
 {
 #ifdef PB_DEVICE_MANAGER_ENABLE
@@ -1043,10 +1155,11 @@ bool PasteboardService::HasPasteData()
     return IsDataVaild(*(it.second), tokenId);
 }
 
-int32_t PasteboardService::SetPasteData(PasteData &pasteData, const sptr<IPasteboardDelayGetter> delayGetter)
+int32_t PasteboardService::SetPasteData(PasteData &pasteData, const sptr<IPasteboardDelayGetter> delayGetter,
+    const sptr<IPasteboardEntryGetter> entryGetter)
 {
     auto data = std::make_shared<PasteData>(pasteData);
-    return SavePasteData(data);
+    return SavePasteData(data, delayGetter, entryGetter);
 }
 
 bool PasteboardService::HasDataType(const std::string &mimeType)
@@ -1189,7 +1302,7 @@ int32_t PasteboardService::GetDataSource(std::string &bundleName)
 }
 
 int32_t PasteboardService::SavePasteData(std::shared_ptr<PasteData> &pasteData,
-    sptr<IPasteboardDelayGetter> delayGetter)
+    sptr<IPasteboardDelayGetter> delayGetter, sptr<IPasteboardEntryGetter> entryGetter)
 {
     PasteboardTrace tracer("PasteboardService, SetPasteData");
     auto tokenId = IPCSkeleton::GetCallingTokenID();
@@ -1216,7 +1329,11 @@ int32_t PasteboardService::SavePasteData(std::shared_ptr<PasteData> &pasteData,
     pasteData->SetTime(time);
     pasteData->SetScreenStatus(GetCurrentScreenStatus());
     pasteData->SetTokenId(tokenId);
-
+    auto dataId = ++dataId_;
+    pasteData->SetDataId(dataId);
+    for (auto &record : pasteData->AllRecords()) {
+        record->SetDataId(dataId);
+    }
     UpdateShareOption(*pasteData);
     CheckAppUriPermission(*pasteData);
     SetWebViewPasteData(*pasteData, appInfo.bundleName);
@@ -1224,10 +1341,17 @@ int32_t PasteboardService::SavePasteData(std::shared_ptr<PasteData> &pasteData,
     RADAR_REPORT(DFX_SET_PASTEBOARD, DFX_CHECK_SET_DELAY_COPY, static_cast<int>(pasteData->IsDelayData()), SET_DATA_APP,
         appInfo.bundleName, LOCAL_DEV_TYPE, DMAdapter::GetInstance().GetLocalDeviceType());
     if (pasteData->IsDelayData()) {
-        auto deathRecipient = new DelayGetterDeathRecipient(appInfo.userId, *this);
+        sptr<DelayGetterDeathRecipient> deathRecipient =
+            new (std::nothrow) DelayGetterDeathRecipient(appInfo.userId, *this);
         delayGetter->AsObject()->AddDeathRecipient(deathRecipient);
         delayGetters_.InsertOrAssign(appInfo.userId, std::make_pair(delayGetter, deathRecipient));
     }
+    if (pasteData->IsDelayRecord()) {
+        sptr<EntryGetterDeathRecipient> deathRecipient =
+            new (std::nothrow) EntryGetterDeathRecipient(appInfo.userId, *this);
+        entryGetter->AsObject()->AddDeathRecipient(deathRecipient);
+        entryGetters_.InsertOrAssign(appInfo.userId, std::make_pair(entryGetter, deathRecipient));
+    }
     auto curTime = static_cast<uint64_t>(duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count());
     PASTEBOARD_HILOGD(PASTEBOARD_MODULE_SERVICE, "curTime = %{public}" PRIu64, curTime);
     copyTime_.InsertOrAssign(appInfo.userId, curTime);
@@ -1243,19 +1367,23 @@ int32_t PasteboardService::SavePasteData(std::shared_ptr<PasteData> &pasteData,
 
 void PasteboardService::RemovePasteData(const AppInfo &appInfo)
 {
-    auto it = clips_.Find(appInfo.userId);
-    auto getter = delayGetters_.Find(appInfo.userId);
-    if (it.first) {
-        RevokeUriPermission(it.second);
-        clips_.Erase(appInfo.userId);
-    }
-    if (getter.first) {
+    clips_.ComputeIfPresent(appInfo.userId, [this](auto, auto &clip) {
+        RevokeUriPermission(clip);
+        return false;
+    });
+    delayGetters_.ComputeIfPresent(appInfo.userId, [](auto, auto &delayGetter) {
         RADAR_REPORT(DFX_SET_PASTEBOARD, DFX_CHECK_SET_DELAY_COPY, DFX_SUCCESS, COVER_DELAY_DATA, DFX_SUCCESS);
-        if (getter.second.first != nullptr && getter.second.second != nullptr) {
-            getter.second.first->AsObject()->RemoveDeathRecipient(getter.second.second);
+        if (delayGetter.first != nullptr && delayGetter.second != nullptr) {
+            delayGetter.first->AsObject()->RemoveDeathRecipient(delayGetter.second);
         }
-        delayGetters_.Erase(appInfo.userId);
-    }
+        return false;
+    });
+    entryGetters_.ComputeIfPresent(appInfo.userId, [](auto, auto &entryGetter) {
+        if (entryGetter.first != nullptr && entryGetter.second != nullptr) {
+            entryGetter.first->AsObject()->RemoveDeathRecipient(entryGetter.second);
+        }
+        return false;
+    });
 }
 
 void PasteboardService::SetWebViewPasteData(PasteData &pasteData, const std::string &bundleName)
diff --git a/services/zidl/include/pasteboard_entry_getter_client.h b/services/zidl/include/pasteboard_entry_getter_client.h
new file mode 100644
index 0000000000000000000000000000000000000000..916e3fb7d5ad06c38485e3e709ead302f6951ddb
--- /dev/null
+++ b/services/zidl/include/pasteboard_entry_getter_client.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef PASTEBOARD_ENTRY_GETTER_CLIENT_H
+#define PASTEBOARD_ENTRY_GETTER_CLIENT_H
+
+#include "entry_getter.h"
+#include "pasteboard_entry_getter_stub.h"
+
+namespace OHOS {
+namespace MiscServices {
+class PasteboardEntryGetterClient : public PasteboardEntryGetterStub {
+public:
+    explicit PasteboardEntryGetterClient(const std::map<uint32_t, std::shared_ptr<UDMF::EntryGetter>> entryGetters);
+    ~PasteboardEntryGetterClient() = default;
+    int32_t GetRecordValueByType(uint32_t recordId, PasteDataEntry& value) override;
+private:
+    std::map<uint32_t, std::shared_ptr<UDMF::EntryGetter>> entryGetters_;
+};
+} // namespace MiscServices
+} // namespace OHOS
+#endif // PASTEBOARD_ENTRY_GETTER_CLIENT_H
\ No newline at end of file
diff --git a/services/zidl/include/pasteboard_entry_getter_proxy.h b/services/zidl/include/pasteboard_entry_getter_proxy.h
new file mode 100644
index 0000000000000000000000000000000000000000..50ac4155aad463845837c0a124d4da6f943d8711
--- /dev/null
+++ b/services/zidl/include/pasteboard_entry_getter_proxy.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef PASTEBOARD_ENTRY_GETTER_PROXY_H
+#define PASTEBOARD_ENTRY_GETTER_PROXY_H
+
+#include "iremote_object.h"
+#include "iremote_proxy.h"
+#include "i_pasteboard_entry_getter.h"
+
+namespace OHOS {
+namespace MiscServices {
+class PasteboardEntryGetterProxy : public IRemoteProxy<IPasteboardEntryGetter> {
+public:
+    explicit PasteboardEntryGetterProxy(const sptr<IRemoteObject> &object);
+    ~PasteboardEntryGetterProxy() = default;
+    int32_t GetRecordValueByType(uint32_t recordId, PasteDataEntry& value) override;
+private:
+    static inline BrokerDelegator<PasteboardEntryGetterProxy> delegator_;
+};
+} // namespace MiscServices
+} // namespace OHOS
+#endif // PASTEBOARD_ENTRY_GETTER_PROXY_H
\ No newline at end of file
diff --git a/services/zidl/include/pasteboard_entry_getter_stub.h b/services/zidl/include/pasteboard_entry_getter_stub.h
new file mode 100644
index 0000000000000000000000000000000000000000..4bc4b8c0ba41ae589388c3d735de6cec0620803d
--- /dev/null
+++ b/services/zidl/include/pasteboard_entry_getter_stub.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef PASTEBOARD_ENTRY_GETTER_STUB_H
+#define PASTEBOARD_ENTRY_GETTER_STUB_H
+
+#include "iremote_stub.h"
+#include "i_pasteboard_entry_getter.h"
+
+namespace OHOS {
+namespace MiscServices {
+class PasteboardEntryGetterStub : public IRemoteStub<IPasteboardEntryGetter> {
+public:
+    PasteboardEntryGetterStub();
+    ~PasteboardEntryGetterStub();
+    int OnRemoteRequest(uint32_t code, MessageParcel& data, MessageParcel& reply, MessageOption& option) override;
+private:
+    int32_t OnGetRecordValueByType(MessageParcel& data, MessageParcel& reply);
+    using Handler = int32_t (PasteboardEntryGetterStub::*)(MessageParcel& data, MessageParcel& reply);
+    std::map<uint32_t, Handler> memberFuncMap_;
+};
+} // namespace MiscServices
+} // namespace OHOS
+#endif // PASTEBOARD_ENTRY_GETTER_STUB_H
\ No newline at end of file
diff --git a/services/zidl/include/pasteboard_service_proxy.h b/services/zidl/include/pasteboard_service_proxy.h
index 5baadd401c35b89795200e22833d230ee790efd5..93cc080dc5cd8f51f5a4c27657a3b534e9cce243 100644
--- a/services/zidl/include/pasteboard_service_proxy.h
+++ b/services/zidl/include/pasteboard_service_proxy.h
@@ -28,10 +28,12 @@ public:
     ~PasteboardServiceProxy() = default;
     DISALLOW_COPY_AND_MOVE(PasteboardServiceProxy);
     virtual void Clear() override;
+    virtual int32_t GetRecordValueByType(uint32_t dataId, uint32_t recordId, PasteDataEntry &value) override;
     virtual int32_t GetPasteData(PasteData &data, int32_t &syncTime) override;
     virtual bool HasPasteData() override;
     virtual std::set<Pattern> DetectPatterns(const std::set<Pattern> &patternsToCheck) override;
-    virtual int32_t SetPasteData(PasteData &pasteData, const sptr<IPasteboardDelayGetter> delayGetter) override;
+    virtual int32_t SetPasteData(PasteData &pasteData, const sptr<IPasteboardDelayGetter> delayGetter,
+        const sptr<IPasteboardEntryGetter> entryGetter) override;
     virtual bool IsRemoteData() override;
     virtual int32_t GetDataSource(std::string &bundleName) override;
     virtual bool HasDataType(const std::string &mimeType) override;
diff --git a/services/zidl/include/pasteboard_service_stub.h b/services/zidl/include/pasteboard_service_stub.h
index 2ce3477b0e4ab1cf298594341385ceef321edaf5..c4429eec2d9a4a934af1c20ac2bbe5367904c098 100644
--- a/services/zidl/include/pasteboard_service_stub.h
+++ b/services/zidl/include/pasteboard_service_stub.h
@@ -21,7 +21,6 @@
 
 #include "ipc_skeleton.h"
 #include "iremote_stub.h"
-#include "i_pasteboard_delay_getter.h"
 #include "i_pasteboard_service.h"
 
 namespace OHOS {
@@ -36,8 +35,10 @@ public:
 private:
     using PasteboardServiceFunc = int32_t (PasteboardServiceStub::*)(MessageParcel &data, MessageParcel &reply);
     virtual int32_t SavePasteData(std::shared_ptr<PasteData> &pasteData,
-        sptr<IPasteboardDelayGetter> delayGetter = nullptr) = 0;
+        sptr<IPasteboardDelayGetter> delayGetter = nullptr,
+        sptr<IPasteboardEntryGetter> entryGetter = nullptr) = 0;
     int32_t OnClear(MessageParcel &data, MessageParcel &reply);
+    int32_t OnGetRecordValueByType(MessageParcel &data, MessageParcel &reply);
     int32_t OnGetPasteData(MessageParcel &data, MessageParcel &reply);
     int32_t OnHasPasteData(MessageParcel &data, MessageParcel &reply);
     int32_t OnSetPasteData(MessageParcel &data, MessageParcel &reply);
diff --git a/services/zidl/src/pasteboard_entry_getter_client.cpp b/services/zidl/src/pasteboard_entry_getter_client.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..291aee85fff66b35650b5abbb9eda39a0ad3bc03
--- /dev/null
+++ b/services/zidl/src/pasteboard_entry_getter_client.cpp
@@ -0,0 +1,43 @@
+/*
+* Copyright (c) 2024 Huawei Device Co., Ltd.
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#include "convert_utils.h"
+#include "pasteboard_error.h"
+#include "pasteboard_entry_getter_client.h"
+#include "pasteboard_hilog.h"
+
+namespace OHOS {
+namespace MiscServices {
+using namespace OHOS::UDMF;
+PasteboardEntryGetterClient::PasteboardEntryGetterClient(
+    const std::map<uint32_t, std::shared_ptr<EntryGetter>> entryGetters) : entryGetters_(entryGetters)
+{
+}
+
+int32_t PasteboardEntryGetterClient::GetRecordValueByType(uint32_t recordId, PasteDataEntry& value)
+{
+    auto it = entryGetters_.find(recordId);
+    if (it == entryGetters_.end()) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "recordId:%{public}d, have no entry getter", recordId);
+        return static_cast<int32_t>(PasteboardError::E_INVALID_VALUE);
+    }
+    auto utdId = value.GetUtdId();
+    if (it->second != nullptr) {
+        value.SetValue(it->second->GetValueByType(utdId));
+    }
+    return static_cast<int32_t>(PasteboardError::E_OK);
+}
+} // namespace MiscServices
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/zidl/src/pasteboard_entry_getter_proxy.cpp b/services/zidl/src/pasteboard_entry_getter_proxy.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..be4b2a0fae3cb7a6f2347cabe91770b602c3fb09
--- /dev/null
+++ b/services/zidl/src/pasteboard_entry_getter_proxy.cpp
@@ -0,0 +1,85 @@
+/*
+* Copyright (c) 2024 Huawei Device Co., Ltd.
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#include "message_option.h"
+#include "message_parcel.h"
+#include "pasteboard_entry_getter_proxy.h"
+#include "pasteboard_hilog.h"
+#include "pasteboard_serv_ipc_interface_code.h"
+
+namespace OHOS {
+namespace MiscServices {
+using namespace OHOS::Security::PasteboardServ;
+PasteboardEntryGetterProxy::PasteboardEntryGetterProxy(const sptr<IRemoteObject> &object)
+    : IRemoteProxy<IPasteboardEntryGetter>(object)
+{
+}
+
+int32_t PasteboardEntryGetterProxy::GetRecordValueByType(uint32_t recordId, PasteDataEntry& value)
+{
+    MessageParcel request;
+    MessageParcel reply;
+    MessageOption option;
+    if (!request.WriteInterfaceToken(GetDescriptor())) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "write descriptor failed");
+        return ERR_INVALID_VALUE;
+    }
+    if (!request.WriteUint32(recordId)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "write recordId failed");
+        return ERR_INVALID_VALUE;
+    }
+    std::vector<uint8_t> sendEntryTLV(0);
+    bool ret = value.Marshalling(sendEntryTLV);
+    if (!ret) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "marshall entry value failed");
+        return ERR_INVALID_VALUE;
+    }
+    if (!request.WriteInt32(sendEntryTLV.size())) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "write entry tlv raw data size failed");
+        return ERR_INVALID_VALUE;
+    }
+    if (!request.WriteRawData(sendEntryTLV.data(), sendEntryTLV.size())) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "write entry tlv raw data failed");
+        return ERR_INVALID_VALUE;
+    }
+    int result = Remote()->SendRequest(
+        static_cast<int>(PasteboardEntryGetterInterfaceCode::GET_RECORD_VALUE_BY_TYPE), request, reply, option);
+    if (result != ERR_OK) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "send request failed, error:%{public}d", result);
+        return ERR_INVALID_OPERATION;
+    }
+    int32_t res = reply.ReadInt32();
+    int32_t rawDataSize = reply.ReadInt32();
+    if (rawDataSize <= 0) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "read entry tlv raw data size failed");
+        return ERR_INVALID_VALUE;
+    }
+    const uint8_t *rawData = reinterpret_cast<const uint8_t *>(reply.ReadRawData(rawDataSize));
+    if (rawData == nullptr) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "read entry tlv raw data failed");
+        return ERR_INVALID_VALUE;
+    }
+    std::vector<uint8_t> recvEntryTlv(rawData, rawData + rawDataSize);
+    PasteDataEntry entryValue;
+    ret = entryValue.Unmarshalling(recvEntryTlv);
+    if (!ret) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "unmarshall entry value failed");
+        return ERR_INVALID_VALUE;
+    }
+    value = entryValue;
+    return res;
+}
+} // namespace MiscServices
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/zidl/src/pasteboard_entry_getter_stub.cpp b/services/zidl/src/pasteboard_entry_getter_stub.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..b9ba9e664f374e1316347248cb5870492837dd75
--- /dev/null
+++ b/services/zidl/src/pasteboard_entry_getter_stub.cpp
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "ipc_skeleton.h"
+#include "pasteboard_entry_getter_stub.h"
+#include "pasteboard_error.h"
+#include "pasteboard_hilog.h"
+#include "pasteboard_serv_ipc_interface_code.h"
+
+namespace OHOS {
+namespace MiscServices {
+using namespace OHOS::Security::PasteboardServ;
+PasteboardEntryGetterStub::PasteboardEntryGetterStub()
+{
+    memberFuncMap_[static_cast<uint32_t>(PasteboardEntryGetterInterfaceCode::GET_RECORD_VALUE_BY_TYPE)] =
+        &PasteboardEntryGetterStub::OnGetRecordValueByType;
+}
+
+PasteboardEntryGetterStub::~PasteboardEntryGetterStub()
+{
+    memberFuncMap_.clear();
+}
+
+int PasteboardEntryGetterStub::OnRemoteRequest(
+    uint32_t code, MessageParcel& data, MessageParcel& reply, MessageOption& option)
+{
+    PASTEBOARD_HILOGI(PASTEBOARD_MODULE_CLIENT, "code:%{public}u, callingPid:%{public}d", code,
+        IPCSkeleton::GetCallingPid());
+    std::u16string localDescriptor = PasteboardEntryGetterStub::GetDescriptor();
+    std::u16string remoteDescriptor = data.ReadInterfaceToken();
+    if (remoteDescriptor != localDescriptor) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "remote descriptor is not equal to local descriptor");
+        return -1;
+    }
+    auto itFunc = memberFuncMap_.find(code);
+    if (itFunc != memberFuncMap_.end()) {
+        auto memberFunc = itFunc->second;
+        if (memberFunc != nullptr) {
+            return (this->*memberFunc)(data, reply);
+        }
+    }
+    return IPCObjectStub::OnRemoteRequest(code, data, reply, option);
+}
+
+int32_t PasteboardEntryGetterStub::OnGetRecordValueByType(MessageParcel& data, MessageParcel& reply)
+{
+    uint32_t recordId = data.ReadUint32();
+    int32_t rawDataSize = data.ReadInt32();
+    if (rawDataSize <= 0) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "read entry tlv raw data size fail");
+        return ERR_INVALID_VALUE;
+    }
+    const uint8_t *rawData = reinterpret_cast<const uint8_t *>(data.ReadRawData(rawDataSize));
+    if (rawData == nullptr) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "read entry tlv raw data fail");
+        return ERR_INVALID_VALUE;
+    }
+    std::vector<uint8_t> recvEntryTlv(rawData, rawData + rawDataSize);
+    PasteDataEntry entryValue;
+    bool ret = entryValue.Unmarshalling(recvEntryTlv);
+    if (!ret) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "unmarshall entry value failed");
+        return ERR_INVALID_VALUE;
+    }
+    auto result = GetRecordValueByType(recordId, entryValue);
+    if (!reply.WriteInt32(result)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "Failed to write result:%{public}d", result);
+        return ERR_INVALID_VALUE;
+    }
+    std::vector<uint8_t> sendEntryTLV(0);
+    ret = entryValue.Marshalling(sendEntryTLV);
+    if (!ret) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "marshall entry value failed");
+        return ERR_INVALID_VALUE;
+    }
+    if (!reply.WriteInt32(sendEntryTLV.size())) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "write entry tlv raw data size failed");
+        return ERR_INVALID_VALUE;
+    }
+    if (!reply.WriteRawData(sendEntryTLV.data(), sendEntryTLV.size())) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "write entry tlv raw data failed");
+        return ERR_INVALID_VALUE;
+    }
+    return ERR_OK;
+}
+} // namespace MiscServices
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/zidl/src/pasteboard_service_proxy.cpp b/services/zidl/src/pasteboard_service_proxy.cpp
index a2394dfbfa294a616bad89eab0c1319c3856ac79..afbb007837ad573472e719b0db0ac75df1527cba 100644
--- a/services/zidl/src/pasteboard_service_proxy.cpp
+++ b/services/zidl/src/pasteboard_service_proxy.cpp
@@ -47,6 +47,62 @@ void PasteboardServiceProxy::Clear()
     }
 }
 
+int32_t PasteboardServiceProxy::GetRecordValueByType(uint32_t dataId, uint32_t recordId, PasteDataEntry &value)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+    if (!data.WriteInterfaceToken(GetDescriptor())) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT,
+            "fail to write descriptor, dataId:%{public}d or recordId:%{public}d", dataId, recordId);
+        return ERR_INVALID_VALUE;
+    }
+    if (!data.WriteUint32(dataId) || !data.WriteUint32(recordId)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT,
+            "fail to write dataId:%{public}d or recordId:%{public}d", dataId, recordId);
+        return ERR_INVALID_VALUE;
+    }
+    std::vector<uint8_t> sendTLV(0);
+    bool ret = value.Marshalling(sendTLV);
+    if (!ret) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "fail encode entry value");
+        return ERR_INVALID_VALUE;
+    }
+    if (!data.WriteInt32(sendTLV.size())) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "fail write data size");
+        return ERR_INVALID_VALUE;
+    }
+    if (!data.WriteRawData(sendTLV.data(), sendTLV.size())) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "fail write raw data");
+        return ERR_INVALID_VALUE;
+    }
+    int32_t result = Remote()->SendRequest(PasteboardServiceInterfaceCode::GET_RECORD_VALUE, data, reply, option);
+    if (result != ERR_NONE) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "failed, error code is:%{public}d", result);
+        return ERR_INVALID_OPERATION;
+    }
+    int32_t res = reply.ReadInt32();
+    int32_t rawDataSize = reply.ReadInt32();
+    if (rawDataSize <= 0) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "fail to get raw data size");
+        return ERR_INVALID_VALUE ;
+    }
+    const uint8_t *rawData = reinterpret_cast<const uint8_t *>(reply.ReadRawData(rawDataSize));
+    if (rawData == nullptr) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "fail to get raw data");
+        return ERR_INVALID_VALUE;
+    }
+    std::vector<uint8_t> receiveTlv(rawData, rawData + rawDataSize);
+    PasteDataEntry entryValue;
+    ret = entryValue.Unmarshalling(receiveTlv);
+    if (!ret) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "fail to decode paste data entry");
+        return ERR_INVALID_VALUE;
+    }
+    value = std::move(entryValue);
+    return res;
+}
+
 bool PasteboardServiceProxy::HasPasteData()
 {
     PASTEBOARD_HILOGD(PASTEBOARD_MODULE_CLIENT, "start.");
@@ -69,9 +125,9 @@ bool PasteboardServiceProxy::HasPasteData()
     return has;
 }
 
-int32_t PasteboardServiceProxy::SetPasteData(PasteData &pasteData, const sptr<IPasteboardDelayGetter> delayGetter)
+int32_t PasteboardServiceProxy::SetPasteData(PasteData &pasteData, const sptr<IPasteboardDelayGetter> delayGetter,
+    const sptr<IPasteboardEntryGetter> entryGetter)
 {
-    PASTEBOARD_HILOGD(PASTEBOARD_MODULE_CLIENT, "start.");
     MessageParcel data;
     MessageParcel reply;
     MessageOption option;
@@ -79,6 +135,12 @@ int32_t PasteboardServiceProxy::SetPasteData(PasteData &pasteData, const sptr<IP
         PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "Failed to write parcelable");
         return ERR_INVALID_VALUE;
     }
+    if (pasteData.IsDelayData() && delayGetter == nullptr) {
+        pasteData.SetDelayData(false);
+    }
+    if (pasteData.IsDelayRecord() && entryGetter == nullptr) {
+        pasteData.SetDelayRecord(false);
+    }
     std::vector<uint8_t> pasteDataTlv(0);
     bool ret = pasteData.Encode(pasteDataTlv);
     if (!ret) {
@@ -98,17 +160,19 @@ int32_t PasteboardServiceProxy::SetPasteData(PasteData &pasteData, const sptr<IP
         PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "Failed to write record uri fd");
         return ERR_INVALID_VALUE;
     }
-    if (pasteData.IsDelayData() &&
-        !data.WriteRemoteObject(delayGetter->AsObject())) {
+    if (pasteData.IsDelayData() && !data.WriteRemoteObject(delayGetter->AsObject())) {
         PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "failed to write delay getter");
         return ERR_INVALID_VALUE;
     }
+    if (pasteData.IsDelayRecord() && !data.WriteRemoteObject(entryGetter->AsObject())) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "failed to write entry getter");
+        return ERR_INVALID_VALUE;
+    }
     int32_t result = Remote()->SendRequest(PasteboardServiceInterfaceCode::SET_PASTE_DATA, data, reply, option);
     if (result != ERR_NONE) {
         PASTEBOARD_HILOGE(PASTEBOARD_MODULE_CLIENT, "failed, error code is: %{public}d", result);
         return ERR_INVALID_OPERATION;
     }
-    PASTEBOARD_HILOGD(PASTEBOARD_MODULE_CLIENT, "end.");
     return reply.ReadInt32();
 }
 
diff --git a/services/zidl/src/pasteboard_service_stub.cpp b/services/zidl/src/pasteboard_service_stub.cpp
index 13c2fc49e36e5e44471c0740048fb7a127aece51..5b0b513d6045e3f64171be3f020343547e8e5299 100644
--- a/services/zidl/src/pasteboard_service_stub.cpp
+++ b/services/zidl/src/pasteboard_service_stub.cpp
@@ -67,6 +67,8 @@ PasteboardServiceStub::PasteboardServiceStub()
             &PasteboardServiceStub::OnPasteComplete;
     memberFuncMap_[static_cast<uint32_t>(PasteboardServiceInterfaceCode::REGISTER_CLIENT_DEATH_OBSERVER)] =
             &PasteboardServiceStub::OnRegisterClientDeathObserver;
+    memberFuncMap_[static_cast<uint32_t>(PasteboardServiceInterfaceCode::GET_RECORD_VALUE)] =
+        &PasteboardServiceStub::OnGetRecordValueByType;
 }
 
 int32_t PasteboardServiceStub::OnRemoteRequest(
@@ -102,6 +104,49 @@ int32_t PasteboardServiceStub::OnClear(MessageParcel &data, MessageParcel &reply
     return ERR_OK;
 }
 
+int32_t PasteboardServiceStub::OnGetRecordValueByType(MessageParcel &data, MessageParcel &reply)
+{
+    uint32_t dataId = data.ReadUint32();
+    uint32_t recordId = data.ReadUint32();
+    PasteDataEntry entryValue;
+    int32_t rawDataSize = data.ReadInt32();
+    if (rawDataSize <= 0) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "fail to get raw data size");
+        return ERR_INVALID_VALUE;
+    }
+    const uint8_t *rawData = reinterpret_cast<const uint8_t *>(data.ReadRawData(rawDataSize));
+    if (rawData == nullptr) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "fail to get raw data");
+        return ERR_INVALID_VALUE;
+    }
+    std::vector<uint8_t> receiveTlv(rawData, rawData + rawDataSize);
+    bool ret = entryValue.Unmarshalling(receiveTlv);
+    if (!ret) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "fail to decode paste data entry");
+        return ERR_INVALID_VALUE;
+    }
+    auto result = GetRecordValueByType(dataId, recordId, entryValue);
+    if (!reply.WriteInt32(result)) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "Failed to write result:%{public}d", result);
+        return ERR_INVALID_VALUE;
+    }
+    std::vector<uint8_t> entryValueTLV(0);
+    ret = entryValue.Marshalling(entryValueTLV);
+    if (!ret) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "fail encode entry value");
+        return ERR_INVALID_VALUE;
+    }
+    if (!reply.WriteInt32(entryValueTLV.size())) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "fail write data size");
+        return ERR_INVALID_VALUE;
+    }
+    if (!reply.WriteRawData(entryValueTLV.data(), entryValueTLV.size())) {
+        PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "fail write raw data");
+        return ERR_INVALID_VALUE;
+    }
+    return ERR_OK;
+}
+
 int32_t PasteboardServiceStub::OnGetPasteData(MessageParcel &data, MessageParcel &reply)
 {
     std::string pasteId = data.ReadString();
@@ -171,22 +216,33 @@ int32_t PasteboardServiceStub::OnSetPasteData(MessageParcel &data, MessageParcel
         PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "Failed to read uri fd");
         return ERR_INVALID_VALUE;
     }
-    int32_t result = 0;
+    sptr<IPasteboardDelayGetter> delayGetter = nullptr;
     if (pasteData->IsDelayData()) {
         sptr<IRemoteObject> obj = data.ReadRemoteObject();
         if (obj == nullptr) {
-            PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "delayGetter is nullptr");
+            PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "delay getter is nullptr");
             return ERR_INVALID_VALUE;
         }
-        auto delayGetter = iface_cast<IPasteboardDelayGetter>(obj);
+        delayGetter = iface_cast<IPasteboardDelayGetter>(obj);
         if (delayGetter == nullptr) {
-            PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "delayGetter is nullptr");
+            PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "delay getter is nullptr");
+            return ERR_INVALID_VALUE;
+        }
+    }
+    sptr<IPasteboardEntryGetter> entryGetter = nullptr;
+    if (pasteData->IsDelayRecord()) {
+        sptr<IRemoteObject> obj = data.ReadRemoteObject();
+        if (obj == nullptr) {
+            PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "entry getter is nullptr");
+            return ERR_INVALID_VALUE;
+        }
+        entryGetter = iface_cast<IPasteboardEntryGetter>(obj);
+        if (entryGetter == nullptr) {
+            PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "entry getter is nullptr");
             return ERR_INVALID_VALUE;
         }
-        result = SavePasteData(pasteData, delayGetter);
-    } else {
-        result = SavePasteData(pasteData);
     }
+    auto result = SavePasteData(pasteData, delayGetter, entryGetter);
     HiViewAdapter::ReportUseBehaviour(*pasteData, HiViewAdapter::COPY_STATE, result);
     if (!reply.WriteInt32(result)) {
         PASTEBOARD_HILOGE(PASTEBOARD_MODULE_SERVICE, "Failed to write SetPasteData result");
diff --git a/utils/native/include/pasteboard_hilog.h b/utils/native/include/pasteboard_hilog.h
index d3c56a8b63429708150ebd07118cb5e747ef1e47..4be66cc768b16bcd57aca85f7226164cfe7cb052 100644
--- a/utils/native/include/pasteboard_hilog.h
+++ b/utils/native/include/pasteboard_hilog.h
@@ -28,6 +28,7 @@ enum PasteboardSubModule {
     PASTEBOARD_MODULE_JNI,
     PASTEBOARD_MODULE_COMMON,
     PASTEBOARD_MODULE_JS_NAPI,
+    PASTEBOARD_MODULE_CAPI,
     PASTEBOARD_MODULE_BUTT,
 };
 
@@ -42,6 +43,7 @@ enum PasteboardDomainId {
     PASTEBOARD_JNI_DOMAIN,
     PASTEBOARD_COMMON_DOMAIN,
     PASTEBOARD_JS_NAPI,
+    PASTEBOARD_CAPI,
     PASTEBOARD_BUTT,
 };
 
@@ -53,6 +55,7 @@ static constexpr OHOS::HiviewDFX::HiLogLabel PASTEBOARD[PASTEBOARD_MODULE_BUTT]
     { LOG_CORE, PASTEBOARD_JNI_DOMAIN, "PBJN" },
     { LOG_CORE, PASTEBOARD_COMMON_DOMAIN, "PBCM" },
     { LOG_CORE, PASTEBOARD_JS_NAPI, "PBJS" },
+    { LOG_CORE, PASTEBOARD_CAPI, "PBCA" },
 };
 
 // In order to improve performance, do not check the module range.
